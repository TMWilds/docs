---
title: Data Sync
---
This article provides step-by-step instructions for setting up, maintaining, and ending data subscriptions for peer-to-peer asynchronous replication:

- [Creating Subscriptions]()
- [Managing Lifetime Subscriptions]()
- [Canceling Subscriptions]()



# Creating Subscriptions

To set up a replication subscription in your app:

<Warning>
Syncing large documents can significantly impact sync performance:

Be cautious handling very large binary data, a deeply embedded document, or a very large document. Carefully consider using `attachments` instead of storing the data directly within a document object. For more information, see [Attachment](<./Data Types.md>) and [Large Binary Files](<./../Standard Best Practices/Large Binary Files.md>).
</Warning>

<Steps>
    <Step>
        Start data replication within your app's development lifecycle. (<a href="#">Initiating Replication</a>)
    </Step>
    <Step>
        Instantiate a top-level `subscription` object. (<a href="#">Creating Subscriptions</a>)
    </Step>
    <Step>
        If applicable, end the subscription. (<a href="#">Canceling Subscriptions</a>)
    </Step>
</Steps>


## Initiating Replication



To initiate replication, early in your app lifecycle, such as within `AppDelegate.application(_:didFinishLaunchingWithOptions:)` or `Application.onCreate` methods, call the `startSync` method.

<Info>
You only need to call the following function once.
</Info>

<Warning>
You must start replication (`startSync`) in the top-most scope to ensure that as soon as your app starts, it automatically connects with the mesh network and remains active throughout your app's lifecycle.

Otherwise, the peer-to-peer connection may fail, resulting in remote peers becoming unable to send you updates in realtime.
</Warning>


<Tabs>
    <Tab title="Swift">
        ```swift
        try! ditto.startSync()
        ```
    </Tab>
    <Tab title="Kotlin">
        ```kotlin
        try {
            ditto.startSync()
        } catch (e: DittoError) {
            // handle error
        }
        ```
    </Tab>
    <Tab title="JavaScript">
        ```javascript
        try {
            ditto.startSync()
        } catch (err) {
            console.error(err)
        }
        ```
    </Tab>
    <Tab title="Java">
        ```java
        try {
            ditto.startSync();
        } catch(DittoError e) {
            // handle error
        }
        ```
    </Tab>
    <Tab title="C#">
        ```csharp
        try
        {
            ditto.StartSync();
        }
        catch (DittoException ex)
        {
            // handle exception
        }
        ```
    </Tab>
    <Tab title="C++">
        ```cpp
        try {
            ditto.start_sync();
        } catch (const DittoError &err) {
            std::cerr << err.what();
        }
        ```
    </Tab>
    <Tab title="Rust">
        ```rust
        ditto.try_start_sync()?;
        ```
    </Tab>
</Tabs>

## Creating Subscriptions

In the top-most scope of your app, following the startSync method called in the previous step, set up a subscription object:

<Warning>
You must declare your subscription object from the top-most scope of your app to ensure access throughout your app.

Otherwise, you cannot modify or cancel your subscription from any part of your code, resulting in difficulty and potential errors when managing the subscription's lifecycle.
</Warning>
1.  Pass your replication query as an argument to find.

2.  Call the Subscribe method, and then pass the subsequent actions and processes you want to execute when your criteria are met as an argument.


Once you've set up your subscription, your subscription query is automatically sent to all peers connected to the mesh network. If there are any data changes that match your criteria, Ditto automatically triggers your subscribe callback function that performs followup actions and processes in your app.

<Tabs>
    <Tab title="Swift">
        ```swift
        let subscription = ditto.store
            .collection("your_collection_name")
            .find(query)
            .subscribe()
        ```
    </Tab>
    <Tab title="Kotlin">
        ```kotlin
        val subscription = ditto.store
            .collection("your_collection_name")
            .find(query)
            .subscribe()
        ```
    </Tab>
    <Tab title="JavaScript">
        ```javascript
        const subscription = ditto.store
          .collection("your_collection_name")
          .find([query])
          .subscribe()
        ```
    </Tab>
    <Tab title="C#">
        ```csharp
        const subscription = ditto.Store
          .Collection("your_collection_name")
          .Find([query])
          .Subscribe()
        ```
    </Tab>
    <Tab title="C++">
        ```cpp
        std::shared_ptr<ditto::Subscription> subscription = ditto.get_store()
          .collection("your_collection_name")
          .find([query])
          .subscribe();
        ```
    </Tab>
    <Tab title="Rust">
        ```rust
        let collection = ditto.store()
          .collection("your_collection_name").unwrap();

        const subscription = collection
          .find([query])
          .subscribe();
        ```
    </Tab>
</Tabs>

For example, the following snippet demonstrates how to establish a `carsSubscription` to listen for all updates to documents in the `"cars"` collection with a field of `color` set to the value `"blue"`:


<Tabs>
    <Tab title="Swift">
        ```swift
        let carsSubscription = ditto.store
          .collection("cars")
          .find("color == 'blue'")
          .subscribe()
        ```
    </Tab>
    <Tab title="Kotlin">
        ```kotlin
        val carsSubscription = ditto.store.collection("cars")
            .find("color == 'blue'")
            .subscribe()
        ```
    </Tab>
    <Tab title="JavaScript">
        ```javascript
        const subscription = ditto.store
          .collection("cars")
          .find("color == 'blue'")
          .subscribe()
        ```
    </Tab>
    <Tab title="C#">
        ```csharp
        var subscription = ditto.store
          .Collection("cars")
          .Find("color == 'blue'")
          .Subscribe()
        ```
    </Tab>
    <Tab title="C++">
        ```cpp
        std::shared_ptr<ditto::Subscription> subscription = ditto.get_store()
          .collection("cars")
          .find("color == 'blue'")
          .subscribe();
        ```
    </Tab>
    <Tab title="Rust">
        ```rust
        const subscription = ditto.store
          .collection("cars")
          .find("color == 'blue'")
          .subscribe();
        ```
    </Tab>
</Tabs>


# Managing Lifetime Subscriptions

# Canceling Subscriptions
<Tabs>
<Tab title="Swift">
```swift
subscription.cancel()
```
</Tab>
<Tab title="Kotlin">
```kotlin
subscription.cancel()
```
</Tab>
<Tab title="JavaScript">
```javascript
subscription.cancel();
```
</Tab>
<Tab title="Java">
```java
```
</Tab>
<Tab title="C#">
```csharp
subscription.Cancel();
```
</Tab>
<Tab title="C++">
```cpp
subscription.cancel();
```
</Tab>
<Tab title="Rust">
```rust
subscription.cancel();
```
</Tab>
</Tabs>

For example, continuing with the previous example, the following snippet illustrates canceling the `carsSubscription`:


<Tabs>
    <Tab title="Swift">
        ```swift
        carsSubscription.cancel()
        ```
    </Tab>
    <Tab title="Kotlin">
        ```kotlin
        carsSubscription.cancel()
        ```
    </Tab>
    <Tab title="JavaScript">
        ```javascript
        carsSubscription.cancel();
        ```
    </Tab>
    <Tab title="C#">
        ```csharp
        carsSubscription.Cancel();
        ```
    </Tab>
    <Tab title="C++">
        ```cpp
        std::shared_ptr<ditto::Subscription> carsSubscription = ditto.get_store()
          .collection("cars")
          .find("color == 'blue'")
          .subscribe();

        carsSubscription.cancel();
        ```
    </Tab>
    <Tab title="Rust">
        ```rust
        carsSubscription.cancel();
        ```
    </Tab>
</Tabs>


