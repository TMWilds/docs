---
title: Best Practices for CRUD
---

To help you make the most out of Ditto's capabilities and ensure a frictionless experience for your end users, implement optimization strategies to enhance the efficiency, speed, and precision of your create, read, update, and delete (CRUD) operations.

This article offers a variety of optimization techniques for improving app performance.

# Querying Dynamic Data Using $args&#x20;

When invoking the Find and Observe Local methods to query values that may change dynamically during runtime, you can declare a top-level args variable that defines the dynamic values, and then pass the the $args identifier within your query conditions.

That way, the query engine separates your query logic from the data so you can easily define and pass values as needed to adapt without having to change the query structure itself.

<Warning>
Using strings to filter dynamic data may impact the maintainability, security, and performance of your app by introducing various issues such as syntax errors in your code.
</Warning>
<Tabs>
  <Tab title="Swift">
    ```swift
    let query = "color == $args.color"
    let args = [ "color": "blue" ]
    let documents = ditto.store
      .collection("your_collection_name")
      .find(query, args)
      .exec()
    ```
  </Tab>

  <Tab title="Kotlin">
    ```kotlin
    val foundDocs = ditto.store.collection("people")
        .find("name == \$args.name && age <= \$args.age", mapOf("name" to "max", "age" to 32))
    ```
  </Tab>

  <Tab title="JavaScript">
    ```javascript
    const query = 'name == $args.name && age <= $args.age'
    const documents = await ditto.store.collection('people').find(query, {
      age: 32,
      name: 'Max',
    })
    ```
  </Tab>

  <Tab title="Java">
    ```java
    Map<String, Object> queryArgs = new HashMap<>();
    queryArgs.put("name", "max");
    queryArgs.put("age", 32);

    List<DittoDocument> foundDocs = ditto.store.collection("users")
            .find("name == $args.name && age <= $args.age", queryArgs)
            .exec();
    ```
  </Tab>

  <Tab title="C#">
    ```csharp
    var docs = ditto.Store
        .Collection("cars")
        .Find(
            "color == $args.color",
            new Dictionary<string, object> { "color", "blue" } )
        .Exec();
    ```
  </Tab>

  <Tab title="C++">
    ```cpp
    json args = json({{"color", "red"}});
    std::vector<Document> big_c_values =
        ditto.get_store()
            .collection("cars")
            .find("color == $args.color", args)
            .exec();
    ```
  </Tab>

  <Tab title="Rust">
    ```rust
    let query = "color == $args.color";
    let args = json!({ "color": "blue" });

    let documents = collection
      .find_with_args(query, args)
      .exec()?;
    ```
  </Tab>
</Tabs>



# Batching Multiple Operations
To reduce the number of network roundtrips needed for each individual operation, ensure data consistency, and simplify your code, use the write method to perform multiple upsert, update, remove, and evict operations across two or more document collections within a single Ditto call.

Additionally, you can incorporate logic that facilitates the retrieval of a document's current state and, when necessary, initiate a conditional

<Warning>
Initiating a write transaction within another write transaction can cause Ditto to hang indefinitely, resulting in a deadlock.

If a deadlock situation occurs, both transactions are unable to complete, the log messages at the ERROR level persist in a forever loop, and you’ll need to review your app’s codebase.
</Warning>

<Warning>
Do not combine Remove and Upsert functions for the same document within a single write transaction.

If you remove a document as part of the operation, potential concurrency conflicts may occur for it is impossible to update a document that no longer exists in Ditto.
</Warning>

The following snippet demonstrates a batch operation in which two write transactions are contained in a single transaction enclosure:


<Tabs>
  <Tab title="Swift">
    ```swift
    ditto.store.write { transaction in
        let cars = transaction.scoped(toCollectionNamed: "cars")
        let people = transaction.scoped(toCollectionNamed: "people")
        let docId = "abc123"
        do {
            try people.upsert(["_id": docId, "name": "Susan"] as [String: Any?])
            try cars.upsert(["make": "Ford", "color": "red", "owner": docId] as [String: Any?])
            try cars.upsert(["make": "Toyota", "color": "black", "owner": docId] as [String: Any?])
        } catch (let err) {
          print(err.localizedDescription)
        }
        people.findByID(docId).evict()
    }
    ```
  </Tab>

  <Tab title="Kotlin">
    ```kotlin
    val results = ditto.store.write { transaction ->
        val cars = transaction.scoped("cars")
        val people = transaction.scoped("people")
        val docId = "abc123"
        people.upsert(mapOf("_id" to docId, "name" to "Susan"))
        cars.upsert(mapOf("make" to "Hyundai", "color" to "red", "owner" to docId))
        cars.upsert(mapOf("make" to "Jeep", "color" to "pink", "owner" to docId))
        people.findById(DittoDocumentId(docId)).evict()
    }
    ```
  </Tab>

  <Tab title="JavaScript">
    ```javascript
    const results = await ditto.store.write(async (transaction) => {
      const cars = transaction.scoped('cars')
      const people = transaction.scoped('people')

      const susanId = await people.upsert({
        name: 'Susan',
      })
      await cars.upsert({
        make: 'Hyundai',
        color: 'red',
        owner: susanId,
      })
      await people.findByID(susanId).evict()
    })
    ```
  </Tab>

  <Tab title="Java">
    ```java
    val results = ditto.store.write { transaction ->
        val cars = transaction.scoped("cars")
        val people = transaction.scoped("people")
        val docId = "abc123"
        people.upsert(mapOf("_id" to docId, "name" to "Susan"))
        cars.upsert(mapOf("make" to "Hyundai", "color" to "red", "owner" to docId))
        cars.upsert(mapOf("make" to "Jeep", "color" to "pink", "owner" to docId))
        people.findById(DittoDocumentId(docId)).evict()
    }
    ```
  </Tab>

  <Tab title="C#">
    ```csharp
    var results = ditto.Store.Write(writeTxn =>
            {
                var collOneTx = writeTxn.Scoped(collectionOne.Name);
                var collTwoTx = writeTxn[collectionTwo.Name];
    ```
  </Tab>

  <Tab title="C++">
    ```cpp
    auto results = ditto.get_store().write([&](WriteTransaction &write_txn) {
      ScopedWriteTransaction people = write_txn.scoped("people");
      ScopedWriteTransaction cars = write_txn.scoped("cars");
      auto docId = "abc123";
      people.upsert({{"name", "Susan"}, {"_id", DocumentId(docId)}});
      cars.upsert({{"make", "Hyundai"}, {"owner", DocumentId(docId)}});
      cars.upsert({{"make", "Toyota"}, {"owner", DocumentId(docId)}});
    });
    ```
  </Tab>

  <Tab title="Rust">
    ```rust
    ditto.store().with_batched_write(|batch| {
        let mut foo_coll = batch.collection("foo");
        foo_coll.find...().remove();
        let mut bar_coll = batch.collection("bar");
        for _ in 0 .. 10_000 {
            let doc = ...;
            bar_coll.insert(doc, None, false);
        }
        batch.commit_changes()
    })
    ```
  </Tab>
</Tabs>


# Using ISO-8601 for Date Strings

# Implementing Write Strategies

## Insert if Absent

<Tabs>
  <Tab title="Swift">
    ```swift
    let initialDocument : [String: Any] = [
      "_id": "123456",
      "color": "blue"
    ]
    let documentId = ditto.store
      .collection("cars")
      .upsert(initialDocument, writeStrategy: .insertIfAbsent)
    ```
  </Tab>

  <Tab title="Kotlin">
    ```kotlin
    val initialDocument = mapOf(
      "_id" to "123456",
      "color" to "blue"
    )
    val documentId = ditto.store
      .collection("cars")
      .upsert(initialDocument, DittoWriteStrategy.InsertIfAbsent)
    ```
  </Tab>

  <Tab title="JavaScript">
    ```javascript
    ```
  </Tab>

  <Tab title="Java">
    ```java
    ```
  </Tab>

  <Tab title="C#">
    ```csharp
    var results = ditto.Store.Write(writeTxn =>
                {
                    var collOneTx = writeTxn.Scoped(collectionOne.Name);
                    // we are also testing the custom subscript accessor
                    var collTwoTx = writeTxn[collectionTwo.Name];

                    docThreeId = collOneTx.Upsert(new Dictionary<string, object> { { "three", "document three" } });
                    docFourId = collOneTx.Upsert(new Dictionary<string, object> { { "four", "document four" } });
                    collOneTx.FindById(docOneId).Evict();

                    docFiveId = collTwoTx.Upsert(new Dictionary<string, object> { { "five", "document five" } });
                    collTwoTx.FindById(docTwoId).Update(doc =>
                    {
                        doc["two"].Set("updated document two");
                    });
    ```
  </Tab>

  <Tab title="C++">
    ```cpp
    auto results = ditto.get_store().write([&](WriteTransaction &write_txn) {
      ScopedWriteTransaction people = write_txn.scoped("people");
      ScopedWriteTransaction cars = write_txn.scoped("cars");
      auto docId = "abc123";
      people.upsert({{"name", "Susan"}, {"_id", DocumentId(docId)}});
      cars.upsert({{"make", "Hyundai"}, {"owner", DocumentId(docId)}});
      cars.upsert({{"make", "Toyota"}, {"owner", DocumentId(docId)}});
    });
    ```
  </Tab>

  <Tab title="Rust">
    ```rust
    ditto.store().with_batched_write(|batch| {
        let mut foo_coll = batch.collection("foo");
        foo_coll.find...().remove();
        let mut bar_coll = batch.collection("bar");
        for _ in 0 .. 10_000 {
            let doc = ...;
            bar_coll.insert(doc, None, false);
        }
        batch.commit_changes()
    })
    ```
  </Tab>
</Tabs>

## Insert Default if Absent



The following snippet shows an example of the `writeStrategy: insertDefaultIfAbsent` parameter passed as an argument to the`upsert` method:

<Tabs>
  <Tab title="Swift">
    ```swift
    do {
        let docID = try ditto.store["people"].upsert([
            "name": "Susan",
            "age": 31
        ], writeStrategy: .insertDefaultIfAbsent)
    } catch {
        //handle error
        print(error)
    }
    ```
  </Tab>

  <Tab title="Kotlin">
    ```kotlin
    val initialDocument = mapOf(
      "_id" to "123456",
      "color" to "blue"
    )
    val documentId = ditto.store
      .collection("cars")
      .upsert(initialDocument, DittoWriteStrategy.InsertDefaultIfAbsent)
    ```
  </Tab>

  <Tab title="JavaScript">
    ```javascript
    const initialDocument = {
      _id: "123456",
      color: "blue"
    }
    const documentId = await ditto.store
      .collection("cars")
      .upsert(initialDocument, { writeStrategy: "insertDefaultIfAbsent" })
    ```
  </Tab>

  <Tab title="Java">
    ```java
    Map<String, Object> content = new HashMap<>();
    content.put("name", "Susan");
    content.put("age", 31);
    DittoDocumentId docId = ditto.store
            .collection("people")
            .upsert(content, DittoWriteStrategy.InsertDefaultIfAbsent);
    ```
  </Tab>

  <Tab title="C#">
    ```csharp
    // Set the intial color to blue
    var initialDocument = new Dictionary<string, object> {
      { "_id", "123456" },
      { "color", "blue" },
    };
    ditto.Store
      .Collection("cars")
      .Upsert(initialDocument, DittoWriteStrategy.InsertDefaultIfAbsent)
    ```
  </Tab>

  <Tab title="C++">
    ```cpp
    DocumentId doc_id = ditto.get_store().collection("people").upsert(
        content, WriteStrategy::insertDefaultIfAbsent);
    ```
  </Tab>

  <Tab title="Rust">
    ```rust
    //not supported in Rust
    ```
  </Tab>
</Tabs>

### Example Use Case: Upserting Initial Data


## Implementing Global Async Transactions

For example, use `DispatchQueue.global`, as follows:


<Tabs>
  <Tab title="Swift">
    ```swift
    DispatchQueue.global(qos: .default).async {

        ditto.store.write { transaction in

            let scope = transaction.scoped(toCollectionNamed: "passengers-\(thisFlight)")

        // Loop inside the transaction to avoid writing to database too frequently
            self.passengers.forEach {
                scope.upsert($0.dict)
            }
        }
    }
    ```
  </Tab>

  <Tab title="Kotlin">
    ```kotlin
    DispatchQueue.global(qos: .default).async {

        ditto.store.write { transaction in

            val scope = transaction.scoped("passengers-$thisFlight")

        // Loop inside the transaction to avoid writing to database too frequently
            self.passengers.forEach {
                scope.upsert(it.dict)
            }
        }
    }
    ```
  </Tab>

  <Tab title="JavaScript">
    ```javascript
    DispatchQueue.global(qos: .default).async {

        ditto.store.write { transaction in

            const scope = transaction.scoped(`passengers-${thisFlight}`)

        // Loop inside the transaction to avoid writing to database too frequently
            this.passengers.forEach(function(passenger) {
                scope.upsert(passenger.dict)
            })
        }
    }
    ```
  </Tab>

  <Tab title="Java">
    ```java
    DispatchQueue.global(qos: .default).async {

        ditto.store.write { transaction ->

            val scope = transaction.scoped("passengers-$thisFlight")

        // Loop inside the transaction to avoid writing to database too frequently
            this.passengers.forEach {
                scope.upsert(it.dict)
            }
        }
    }
    ```
  </Tab>

  <Tab title="C#">
    ```csharp
    DispatchQueue.global(qos: .default).async {

        ditto.store.write { transaction in

            let scope = transaction.scoped(toCollectionNamed: "passengers-\(thisFlight)")

        // Loop inside the transaction to avoid writing to database too frequently
            self.passengers.forEach {
                scope.upsert($0.dict)
            }
        }
    }
    ```
  </Tab>

  <Tab title="C++">
    ```cpp
    DispatchQueue.global(qos: .default).async {

        ditto.store.write { transaction in

            auto scope = transaction.scoped("passengers-" + thisFlight)

        // Loop inside the transaction to avoid writing to database too frequently
            for (const auto& passenger : passengers) {
                scope.upsert(passenger.dict)
            }
        }
    }
    ```
  </Tab>

  <Tab title="Rust">
    ```rust
    //not supported in Rust
    ```
  </Tab>
</Tabs>


## Avoiding Deadlocks

### Example of a Deadlock

The following snippet demonstrates a queued write transaction that has the potential to create a deadlock situation. This is because the write transaction initiated on the `"people"` collection, along with its nested write transaction on the `"settings"` collection both attempt to acquire resources held by the other:


<Tabs>
  <Tab title="Swift">
    ```swift
    // Start a write transaction:
    ditto.store["people"].findByID(docID).update { mutableDoc in
      // Start a write transaction _within_ a write transaction.
      // !! Deadlocks !!
      let docID = try! ditto.store["settings"].upsert([
          "_id": "abc123",
          "preference": 31,
      ])
      // ...
    }
    ```
  </Tab>

  <Tab title="Kotlin">
    ```kotlin
    // Start a write transaction:
    ditto.store["people"].findByID(docID).update { mutableDoc in
      // Start a write transaction _within_ a write transaction.
      // !! Deadlocks !!
      val docID = try! ditto.store["settings"].upsert([
          "_id": "abc123",
          "preference": 31,
      ])
      // ...
    }
    ```
  </Tab>

  <Tab title="JavaScript">
    ```javascript
    // Start a write transaction:
    ditto.store["people"].findByID(docID).update { mutableDoc in
      // Start a write transaction _within_ a write transaction.
      // !! Deadlocks !!
      let docID = try! ditto.store["settings"].upsert([
          "_id": "abc123",
          "preference": 31,
      ])
      // ...
    }
    ```
  </Tab>

  <Tab title="Java">
    ```java
    // Start a write transaction:
    ditto.store["people"].findByID(docID).update { mutableDoc in
      // Start a write transaction _within_ a write transaction.
      // !! Deadlocks !!
      let docID = try! ditto.store["settings"].upsert([
          "_id": "abc123",
          "preference": 31,
      ])
      // ...
    }
    ```
  </Tab>

  <Tab title="C#">
    ```csharp
    // Start a write transaction:
    ditto.store["people"].findByID(docID).update { mutableDoc in
      // Start a write transaction _within_ a write transaction.
      // !! Deadlocks !!
      let docID = try! ditto.store["settings"].upsert([
          "_id": "abc123",
          "preference": 31,
      ])
      // ...
    }
    ```
  </Tab>

  <Tab title="C++">
    ```cpp
    // Start a write transaction:
    ditto.store["people"].findByID(docID).update { mutableDoc in
      // Start a write transaction _within_ a write transaction.
      // !! Deadlocks !!
      let docID = try! ditto.store["settings"].upsert([
          "_id": "abc123",
          "preference": 31,
      ])
      // ...
    }
    ```
  </Tab>

  <Tab title="Rust">
    ```rust
    //not supported in Rust
    ```
  </Tab>
</Tabs>


### Log Message: Transaction Remains Blocked

```json
LOG_LEVEL: Waiting for write transaction (elapsed: XXs), originator=User blocked_by=User
```
