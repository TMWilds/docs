---
title: Evicting and Removing
---
- [Considerations]()
- [Evict Method]()
- [Remove Method]()
- [Soft-Delete Pattern]()

# Considerations

## Access Frequency and Relevance Considerations

In peer-to-peer system design, there are technical tradeoffs between the amount of data synced across peers and the timeliness of access to synced data:

- The greater the amount of data synced across connected peer devices, the more timely offline read access becomes. That is, database resilience in offline scenarios increases when there are more documents being synced across distributed peers.

- The fewer the number of documents replicated, the less the likelihood that peer devices run out of disk space and experience memory leaks, and the performance of the peer-to-peer mesh network that interconnects them degrades.

<Info>
For considerations on using the Evict and Subscribe methods, see [Timing Subscriptions and Evictions]().
</Info>

<Info>
For advanced concepts related to design tradeoffs in distributed system architecture, see [Cloud-Optional Design](<./../Sync and Replication Concepts/Cloud-Optional Design.md>).
</Info>

# Evict Method


<Tabs>
  <Tab title="Swift">
    ```swift
    ditto.store
      .collection("your_collection_name")
      .find([query])
      .evict()
    ```
  </Tab>

  <Tab title="Kotlin">
    ```kotlin
    ditto.store["your_collection_name"]
      .find([query])
      .evict()
    ```
  </Tab>

  <Tab title="JavaScript">
    ```javascript
    await ditto.store
      .collection("your_collection_name")
      .find([query])
      .evict()
    ```
  </Tab>

  <Tab title="Java">
    ```java
    ditto.store
      .collection("your_collection_name")
      .find([query])
      .evict();
    ```
  </Tab>

  <Tab title="C#">
    ```csharp
    ditto.Store
      .Collection("your_collection_name")
      .Find([query])
      .Evict()
    ```
  </Tab>

  <Tab title="C++">
    ```cpp
    ditto.get_store()
      .collection("your_collection_name")
      .find([query])
      .evict()
    ```
  </Tab>

  <Tab title="Rust">
    ```rust
    let collection = ditto.store()
      .collection("your_collection_name").unwrap();

    collection
      .find([query])
      .evict()
      .unwrap();
    ```
  </Tab>
</Tabs>


## Using Evict for Local and Live Queries

<Tabs>
  <Tab title="Swift">
    ```swift
    ditto.store
      .collection("cars")
      .find("color == 'blue'")
      .evict()
    ```
  </Tab>

  <Tab title="Kotlin">
    ```kotlin
    ditto.store
      .collection("cars")
      .find("color == 'blue'")
      .evict()
    ```
  </Tab>

  <Tab title="JavaScript">
    ```javascript
    await ditto.store
      .collection("cars")
      .find("color == 'blue'")
      .evict()
    ```
  </Tab>

  <Tab title="Java">
    ```java
    ditto.store
      .collection("cars")
      .find("color == 'blue'")
      .evict();
    ```
  </Tab>

  <Tab title="C#">
    ```csharp
    ditto.Store
      .Collection("cars")
      .Find("color == 'blue'")
      .Evict()
    ```
  </Tab>

  <Tab title="C++">
    ```cpp
    ditto.get_store()
      .collection("cars")
      .find("color == 'blue'")
      .evict()
    ```
  </Tab>

  <Tab title="Rust">
    ```rust
    cars
      .find("color == 'blue'")
      .evict()
      .unwrap();
    ```
  </Tab>
</Tabs>



For more information, see [Finding and Observing](<./Finding and Observing.md>).

## Using Evict for Replication Queries

## Timing Subscriptions and Evictions

In addition, take a balanced approach when using the Subscribe and Evict methods; as in, consider the advantages and drawbacks of each method and use them as appropriate for the specific needs and requirements of your app.

Key considerations for using Subscription and Eviction methods include:

- Use Subscribe to sync more data across connected peers in the mesh, but be mindful of potential increased network usage that may degrade performance.

- Use Evict to remove data stored locally in an effort to manage local storage capacity and improve performance.

## Forcing Evictions


<Tabs>
  <Tab title="Swift">
    ```swift
    collection
      .find("isSafeToEvict == false")
      .subscribe()
    ```
  </Tab>

  <Tab title="Kotlin">
    ```kotlin
    collection
      .find("isSafeToEvict == false")
      .subscribe()
    ```
  </Tab>

  <Tab title="JavaScript">
    ```javascript
    collection
      .find("isSafeToEvict == false")
      .subscribe()
    ```
  </Tab>

  <Tab title="Java">
    ```java
    collection
    .find("isSafeToEvict == false")
    .subscribe()
    ```
  </Tab>

  <Tab title="C#">
    ```csharp
    let liveQuery = ditto
      .store.collection('cars')
      .find('!isSafeToEvict').observeLocal((documents) => {
        console.log('these are the unarchived documents', documents)
      })
    ```
  </Tab>

  <Tab title="C++">
    ```cpp
    collection.find("isSafeToEvict == false").subscribe()
    ```
  </Tab>

  <Tab title="Rust">
    ```rust
    collection.find("isSafeToEvict == false").subscribe()
    ```
  </Tab>
</Tabs>


# Remove Method



<Warning>
Invoking the `remove` method results in irreversible data loss. &#x20;

Once a document is removed, it is permanently eliminated throughout the Ditto system and can never be restored; however, as of Ditto version 4.0 release, if a document was previously removed, you can reverse the removal. For more information, see [Reversing Removal Operations]().
</Warning>

## Removing Documents

<Tabs>
  <Tab title="Swift">
    ```swift
    collection.findByID(docID).remove()
    ```
  </Tab>

  <Tab title="Kotlin">
    ```kotlin
    collection.findById(docId).remove()
    ```
  </Tab>

  <Tab title="JavaScript">
    ```javascript
    await ditto.store
      .collection("your_collection_name")
      .findByID("unique_document_id")
      .remove()
    ```
  </Tab>

  <Tab title="Java">
    ```java
    ditto.store
        .collection("your_collection_name")
        .findByID("unique_document_id")
        .remove();
    ```
  </Tab>

  <Tab title="C#">
    ```csharp
    ditto.store
      .Collection("your_collection_name")
      .FindByID("unique_document_id")
      .Remove()
    ```
  </Tab>

  <Tab title="C++">
    ```cpp
    ditto.get_store()
      .collection("your_collection_name")
      .find_by_id("unique_document_id")
      .remove()
    ```
  </Tab>

  <Tab title="Rust">
    ```rust
    collection.find_by_id(id).remove().unwrap();
    ```
  </Tab>
</Tabs>


<Tabs>
  <Tab title="Swift">
    ```swift
    let carsCollection = ditto.store.collection("cars")

    // Remove the document with ID "123456" from the collection
    if let document = carsCollection.findById(123456) {
        do {
            try document.remove()
        }
    }
    ```
  </Tab>

  <Tab title="Kotlin">
    ```kotlin
    val carsCollection = ditto.store.collection("cars")

    try {
        carsCollection.findById(123456).remove()
    }
    ```
  </Tab>

  <Tab title="JavaScript">
    ```javascript
    await ditto.store.collection("cars").findByID("123456").remove()
    ```
  </Tab>

  <Tab title="Java">
    ```java
    DittoCollection carsCollection = ditto.store.collection("cars");

    // Remove the document with ID "123456" from the collection
    DittoDocument document = carsCollection.find("id == '123456'");
    ```
  </Tab>

  <Tab title="C#">
    ```csharp
    ditto.store.Collection("cars").FindByID("123456").Remove()
    ```
  </Tab>

  <Tab title="C++">
    ```cpp
    ditto.get_store().collection("cars").find_by_id("123456").remove()
    ```
  </Tab>

  <Tab title="Rust">
    ```rust
    cars.findByID("123456").remove().unwrap()
    ```
  </Tab>
</Tabs>


# Soft-Delete Flag

## Adding a Soft-Delete Flag

To add a soft-delete pattern, set the `isArchived` field value to `true`:

```json JSON
{
  "_id": "123abc",
  "name": "Foo",
  "isArchived": true // add this field
}
```

## Querying Non-Archived Documents

To query to monitor documents that are  `NOT`* *archived, establish a live query using the Find method enclosed with `!isArchived`, and then construct your live query callback.&#x20;

For example, the following code demonstrates looking for documents that are not archived. Once found, the documents output, or `log`, to your console.&#x20;

```javascript
let liveQuery = ditto
  .store.collection('cars')
  .find('!isArchived').observeLocal((documents) => {
    console.log('these are the unarchived documents', documents)
  })
```

## Removing Soft-Delete Flag

To remove the flag and reactivate the document, set the `isArchived` field to `false`:&#x20;

```javascript
ditto.store.collection('cars').update((mutableDoc) => {
  mutableDoc["isArchived"] = false
})
```

