---
title: Map
description: With conflict-free replicated data type (CRDT) technology, each document is represented as a `map`. A `map` is useful when you want to create a list of items and update items over time within a document.&#x20;
---
# Basic Structure

A `map` is a JSON-like object that serves as the basis of each Ditto document and is structured as a collection of field-value pairs:

- To represent simple values in a `map`, use any primitive data type, such as a `string`, `boolean`, `number`, and so on.

- To represent a highly-complex data structure in a `map`, use `register`, `counter`, `array`, or embed another `map`. Embedding a `map` within another map establishes an additional hierarchy.&#x20;

The following snippet demonstrates a Ditto document with an embedded `map`:


```json JSON
{
  "_id": "123546"
  "boolean": true,
  "string": "Hello World",
  "number": 10,
  "map": {
    "key": "value",
  }
}
```

# Characteristics and Behaviors



# Embedding a Map

To create a single `map` represented as a JSON-like root object in the document, use the following data model:


<Tabs>
  <Tab title="Swift">
    ```swift
    do {
        // Insert JSON-compatible data into Ditto
        try ditto.store["foo"].upsert([
            "boolean": true,
            "string": "Hello World",
            "number": 10,
            "map": ["key": "value"],
            "array": [1,2,3],
            "null": nil
        ])
    }
    catch {
        //handle error
        print(error)
    }
    ```
  </Tab>
  <Tab title="Kotlin">
    ```kotlin
    ditto.store["foo"].upsert(mapOf(
        "boolean" to true,
        "string" to "Hello World",
        "number" to 10,
        "map" to mapOf("key" to "value"),
        "array" to listOf(1,2,3),
        "null" to null
    ))
    ```
  </Tab>
  <Tab title="JavaScript">
    ```javascript
    // Insert JSON-compatible data into Ditto
    await ditto.store.collection('people').upsert({
      boolean: true,
      string: 'Hello World',
      number: 10,
      map: { key: 'value' },
      array: [],
      null: null,
    })
    ```
  </Tab>
  <Tab title="Java">
    ```java
    // Insert JSON-compatible data into Ditto
    Map<String, Object> content = new HashMap<>();
    content.put("boolean", true);
    content.put("string", "Hello World");
    content.put("number", 10);

    Map<String, String> innerMap = new HashMap<>();
    innerMap.put("key", "value");
    content.put("map", innerMap);
    content.put("array", Arrays.asList(1, 2, 3));
    content.put("null", null);
    ditto.store.collection("foo").upsert(content);
    ```
  </Tab>
  <Tab title="C#">
    ```csharp
    var content = new Dictionary<string, object>
    {
        { "boolean", true },
        { "string", "Hello World" },
        { "number", 10 },
        { "map", new Dictionary<string, string>{{ "key", "value"}} },
        { "array", new[] {1, 2, 3} },
        { "null", null }
    };
    Ditto.Store.Collection("foo").Upsert(content);
    ```
  </Tab>
  <Tab title="C++">
    ```cpp
    // Insert JSON-compatible data into Ditto
    ditto.get_store().collection("foo").upsert(json({{"boolean", true},
                                                     {"string", "Hello World"},
                                                     {"number", 10},
                                                     {"map", {{"key", "value"}}},
                                                     {"array", {1, 2, 3}}},
                                                     {"null", NULL}}));
    ```
  </Tab>
  <Tab title="Rust">
    ```rust
    collection
        .upsert(json!({
          "boolean": true,
          "string": "Hello World",
          "number": 10,
          "map": {
            "key": "value"
          },
          "array": [1,2,3],
          "null": null,
        }))
        .unwrap();
    ```
  </Tab>
</Tabs>


```json JSON
{
  "parent": "Susan",
  "map": {
    "child1": {
      "key1": "value1",
      "key2": "value2"
    },
    "child2": {
      "key1": "value3",
      "key2": "value4"
    }
  }
}
```


# Updating a Map



## Preferred: Set Specific Value** **

By calling the Remove method, as follows, you omit only the `foo` field from the `friends` `map` within the document, while the other fields within the `friends` `map` remain unaffected:


```javascript pseudocode
collection.findByID("map_test").update(doc => {
  doc.at("friends.foo").set("bar")
})
```


## Not Recommended: Update Entire Map

The following snippet results in all of the values in the friends map being replaced with the new object: `({ "beep": "boop" }):`


```javascript pseudocode
collection.findByID("map_test").update(doc => {
  doc.at("friends").set({
     "beep": "boop"
  })
})
```


# Removing a Map

Since CRDT `map` values merge with the existing document, simply omitting them from the CRDT `map` does not remove them.&#x20;

Instead, the CRDT `map` creates an operation for that field, and subsequently the existing fields remain unchanged.[â€‹](https://docs.ditto.live/javascript/common/datamodel/map#remove)

## Preferred: Update Specific Value

By calling the Remove method, as follows, you omit only the `foo` field from the `friends` `map` within the document, while the other fields within the `friends` `map` remain unaffected:


```javascript pseudocode
collection.findByID("map_test").update(doc => {
  doc.at("friends.foo").set("bar")
})
```


## Not Recommended: Update Entire Map

When you want to clear the entire `map` structure embedded in the document, call the `set` method.

For example, the following snippet illustrates the process of removing the `friends` `map` through the `set `method, making it empty.&#x20;



```javascript pseudocode
collection.findByID("map_test").update(doc => {
  doc.at("friends").set({
     "beep": "boop"
  })
})
```


# Handling Type-Level Concurrency Conflicts

An issue unique to `maps` is the possibility for two offline peers to create a new document, in which one peer represents the field as an object (`map`), while the other peer represents the field as an `array`.

## Example Scenario: Divergent Types Preventing Merge

The following snippets illustrate a scenario of a type-level conflict unique to `maps`.&#x20;

Peer A creates the following new document:


```json JSON
{
  "name":"Bob Jones",
  "address": {
    "street":"Long Road",
    "house number":10298,
    "zip":"90210"
  }
}
```


While at the same time Peer B creates the following new document:


```json JSON
{
  "name": "Bob Jones",
  "address":[
    10298,
    "Long Road",
    "90210"
  ]
}
```




## Preventing the Ping-Pong Effect

# Managing Concurrency Conflicts: Update History

## Example Scenario: Using a Map for Concurrent Updates

Imagine a scenario in which two Ditto stores, peer A and peer B, have the following document:


```json JSON
{
  "_id": "abc123",
  "color": "red",
  "make": "Toyota",
  "mileage": 160000,
  "inspections": "<very large map>"
}
```


Peer A calls the Upsert method to change the field-value `color:red` to `color:blue`:


<Tabs>
  <Tab title="Kotlin">
    ```kotlin
    val initialDocument = mapOf(
      "_id" to "abc123",
      "color" to "blue"
    )
    ```
  </Tab>
  <Tab title="JavaScript">
    ```javascript
    upsert({
      _id: "abc123",
      color: "blue"
    })
    ```
  </Tab>
</Tabs>



While at the same time peer B calls the Update method to change the value of the `mileage` field:&#x20;


<Tabs>
  <Tab title="Kotlin">
    ```kotlin
    findById("abc123").update(doc => {
      doc.mileage.incrememt(200)
    })
    ditto.store.collection("cars").update(initialDocument)
    ```
  </Tab>
  <Tab title="JavaScript">
    ```javascript
    findById("abc123").update(doc => {
      doc.mileage.incrememt(200)
    })
    ```
  </Tab>
</Tabs>



When the changes replicate across the distributed peers, both changes merge resulting in both peer A and peer B Ditto stores having the mileage `increment` of `200` and the `color` change to `blue`:&#x20;

```json JSON
{
  "_id": "abc123",
  "color": "blue",
  "make": "Toyota",
  "mileage": 160200,
  "smogReports": "<very long json blob>"
}
```


