---
title : Data Structures and Types
---

Ditto provides a flexible and efficient way to store and manage data so you can efficiently sync data for a wide range of use cases.&#x20;

Different data structures in Ditto have distinct behaviors and characteristics that you'll need to be familiar with to achieve your specific goals. &#x20;

This article provides a quick overview of Ditto's [schema-flexible document model]() and [advanced data types]().&#x20;

<Info>
For an overview of the various operators and path navigations you can use to construct sophisticated queries in your app, see _Platform Manual_ > [Query Syntax](<./../Platform Manual/Query Syntax.md>).
</Info>

# Schema-Flexible Document Objects

Each document is nested with a hash-stable tree structure that self-describes the data to be stored and provides the predetermined rules that ensure data consistency and accuracy.&#x20;

In simpler terms, each document in Ditto is essentially a key-value pair, where the key is a name (`string`) and the value can be any supported type in Ditto, which includes `maps`. For more information, see [Fields](), as follows.

## Supported Types

In Ditto's document model, the supported data types depend on the CRDTs associated with the document. For more information about CRDTs, see the _Platform Manual _> [Data Types](<./../Platform Manual/Data Types.md>) and [Document Model](<./../Platform Manual/Document Model.md>).

The following snippet provides an example of a basic JSON‑like document object:

```json JSON
{
  "_id" "123abc",
  "name": "Sam",
  "age": 45,
  "isOnline": false
}
```

## Document Size and Sync Performance

Syncing large documents can significantly impact network performance. Instead of storing files exceeding 250kb directly within a document object, carefully consider using `attachments` .&#x20;

<Warning>
Caution is advised when handling large binary data, such as a high‑resolution image or video exceeding 50 megapixels; a deeply embedded document; or a very large document.
</Warning>

For more information, see any of the following:

- _Ditto Basics _> [Attachment Objects](), as follows.
- _Platform Manual _> Document Model:
  - [Complex Structures](<./../Platform Manual/Document Model/Complex Structures.md>)
  - [Evaluation Criteria](<./../Platform Manual/Document Model/Evaluation Criteria.md>)
  - [Relationships](<./../Platform Manual/Document Model/Relationships.md>)
- _Platform Manual _> Data Types > [Attachment](<./../Platform Manual/Data Types/Attachment.md>)

## Fields

A document consists of sets of fields that self‑describe the data it encodes. Each set signifies a single pair of two associated elements:

- The name identifying the data. (See [Field Property](<./../Platform Manual/Document Model/Fields and Key-Values.md>))
- The value that holds the actual data to store. (See [Field Values](<./../Platform Manual/Document Model/Fields and Key-Values.md>))

Required and randomly generated and assigned by default upon creation, the first set of fields identifies the document. (See [Document Identifiers]())

## Document Identifiers

Ditto automatically generates and assigns each new document a unique identifier, or `_id`.

However, if desired, you can pass your own custom `_id` as a parameter in the `upsert` function you use to create a new document. (See [CRUD Fundamentals](<./CRUD Fundamentals.md>))

In addition to having the option to supply your own `_id`, in complex scenarios where you want to create a more intricate and unique identifier for your documents, you can combine two or more distinct elements to form a composite key.&#x20;

For more comprehensive information and how-to instructions, see the _Platform Manual _> [CRUD Operations](<./../Platform Manual/CRUD Operations.md>) > [Upserting and Updating](<./../Platform Manual/CRUD Operations/Upserting and Updating.md>).

## Collection Indexes

If there is a set of documents that contain the same commonly-queried field, such as a string reference to `cars`, you can optimize query speed and reduce peer storage usage by grouping them in an index, or a _collection_.&#x20;

The following snippet and corresponding table provide an example of a string reference to the collection `cars`.

```javascript
const carsCollection = ditto.store.collection('cars')
```

To help better understand, think of a collection\* *like a SQL database *table* and the documents it holds* *like table *rows\*:

<Frame>
<img src="/images/v4-4/image-21.png"/>
</Frame>

## Attachment Objects

To improve performance, instead of storing a file that encodes large amounts of binary data as a document, you can opt to store it as a separate, explicitly fetched object known as an `attachment`.

With the `attachment` CRDT, you can sync between peers without querying and merging.&#x20;

For more comprehensive information and how-to instructions, see the _Platform Manual _> Data Types > [Attachment](<./../Platform Manual/Data Types.md>).

## Relationship Models

The following table provides a complete overview of the relationships you can establish in Ditto:&#x20;

For more information, see _Ditto Basics_ > [CRUD Fundamentals](<./CRUD Fundamentals.md>) and _Platform Manual _> [CRUD Operations](<./../Platform Manual/CRUD Operations.md>).

# Advanced Data Types

As a semi-structured distributed database, Ditto leverages conflict‑free replicated data types (_CRDT_) technology to enable advanced data exchange capabilities.

To get the most out of Ditto, you'll need to work with one or more CRDTs. The`register` type is the most common and simple type to use.

For more information, see _Platform Manual _>\* \* [Register](<./../Platform Manual/Data Types.md>).

## Overview

The following table provides a quick overview of the advanced data types you can use in Ditto, along with their guiding principles for conflict resolution, or _merge semantics_, a brief description, and a common usage scenario:

<Info>
In Ditto's document model, the supported primitive data types depend on the CRDTs associated with the document. For an overview of the data types that each CRDT allows, see _Platform Manual_ > [Data Types](<./../Platform Manual/Data Types.md>).
</Info>

| **Type** | **Merge Semantics** | **Description** | **Use Case** |
| --- | --- | --- | --- |
| register | Last‑Write‑Wins Register,   Delta-state replication | Stores a single value and allows for concurrent updates. | Updates associated with later temporal timestamps *always* win. |
| map | Add-Wins Map,  Delta-state replication | Working in conjunction with the Register, stores the mapping of temporal timestamps to the values written in the Register to help resolve concurrency conflicts. | Make a list of items in a document and update those items over time. |
| counter | Positive or Negative Counter,  The sum of all Site\_ID Counters,  Delta-state replication | Converts a number value for a given key into a Counter.  Unlike a primitive number, value increments and decrements merge without conflict. | Manage inventory and handle votes, such as stock details and survey results. |
| attachment | Last-Write‑Wins Register,  Merges only when explicitly fetched | Stores very large amounts of binary data, such as an image file, and allows for concurrent updates. | Reduce Small Peer resource usage by storing data outside of memory. |
| array | Last‑Write‑Wins Register,  Delta-state replication | An extension of the register type, |  |
