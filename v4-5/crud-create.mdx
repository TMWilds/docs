---
title: CREATE
description: This article provides an overview of creating documents using the INSERT DQL operation.
---

All modification operations in Ditto are performed using the execute API method against the ditto.store:

<Tabs>
  <Tab title="Swift">
```swift
let result = try await ditto.store.execute(query: /* query */, arguments: /* arguments */);
```
  </Tab>
  <Tab title="Kotlin">
```Kotlin
var result = ditto.store.execute(/* query */, /* arguments */)
```
  </Tab>
  <Tab title="JS">
```JS
const result = await ditto.store.execute(/* query */, /* arguments */)
```
  </Tab>
  <Tab title="Java">
```Java
DittoQueryResult result = (DittoQueryResult) ditto.store.execute(
  /* query */,
  /* arguments */,
  /* continuation */);
```
  </Tab>
  <Tab title="C#">
```C#
var result = await ditto.Store.ExecuteAsync(/* query */, /* arguments */);
```
  </Tab>
  <Tab title="C++">
```cpp
auto result = ditto.get_store().execute(/* query */, /* arguments */).get();
```
  </Tab>
  <Tab title="Rust">
```Rust
let result = ditto.store().execute(/* query */, /* arguments */);
```
  </Tab>
</Tabs>
When writing updates by way of the execute API method with INSERT operation:

* If the document does _not_ exist locally, Ditto creates it.

* If the document already exists in the local store, Ditto throws an error.

* If the document is inserted by two or more peers at the same time, the documents that were inserted after the first document will be treated as having performed an UPDATE operation for all fields.


## Creating A New Document

<Tabs>
  <Tab title="Swift">
```swift
await ditto.store.execute(
  query: "INSERT INTO cars DOCUMENTS (:newCar)",
  arguments: ["newCar": ["color": "blue"]]);
```
  </Tab>
  <Tab title="Kotlin">
```Kotlin
ditto.store.execute(
  "INSERT INTO cars DOCUMENTS (:newCar)",
  mapOf("newCar" to mapOf("color" to "blue")))
```
  </Tab>
  <Tab title="JS">
```JS
await ditto.store.execute(
  "INSERT INTO cars DOCUMENTS (:newCar)",
  { newCar: { color: "blue" } });
```
  </Tab>
  <Tab title="Java">
```Java
DittoQueryResult result = (DittoQueryResult) ditto.store.execute(
    "INSERT INTO cars DOCUMENTS (:newCar)",
    Collections.singletonMap("newCar", Collections.singletonMap("color", "blue")),
);
```
  </Tab>
  <Tab title="C#">
```C#
var args = new Dictionary<string, object>();
args.Add("newCar", new { color = "blue" });

await ditto.Store.ExecuteAsync(
  "INSERT INTO cars DOCUMENTS (:newCar)",
  args);
```
  </Tab>
  <Tab title="C++">
```cpp
std::map<std::string, std::map<std::string, std::string>> args;
args["newCar"] = {{"color", "blue"}};

auto result = ditto.get_store().execute(
  "INSERT INTO cars DOCUMENTS (:newCar)",
  args).get();
```
  </Tab>
  <Tab title="Rust">
```Rust
use serde::Serialize;

#[derive(Serialize)]
struct Args {
  newCar: Car,
}
#[derive(Serialize)]
struct Car {
  color: String
}

// ...

let args = Args {
  newCar: Car {
    color: "blue".to_string()
  },
};

ditto.store().execute(
  "INSERT INTO cars DOCUMENTS (:newCar)",
  Some(args.into()));
```
  </Tab>
</Tabs>
For complete DQL syntax, see _Ditto Query Language (DQL)_ \> [INSERT](#poKcNKEX_OxyeJKOAUPTi)

## Creating Multiple Documents

Multiple documents can be created at the same time using the INSERT operation.
<Tabs>
  <Tab title="Swift">
```swift
await ditto.store.execute(
  query: "INSERT INTO cars DOCUMENTS (:car1), (:car2)",
  arguments: [
    "car1": ["color": "blue"],
    "car2": ["color": "red"]
  ]);
```
  </Tab>
  <Tab title="Kotlin">
```Kotlin
ditto.store.execute(
  "INSERT INTO cars DOCUMENTS (:car1),(:car2)",
  mapOf(
    "car1" to mapOf("color" to "blue"),
    "car2" to mapOf("color" to "red")
  ))
```
  </Tab>
  <Tab title="JS">
```JS
await ditto.store.execute(
  "INSERT INTO cars DOCUMENTS (:car1),(:car2)",
  {
    car1: { color: 'blue' },
    car2: { color: 'red' }
  });
```
  </Tab>
  <Tab title="Java">
```Java
Map<String, Map<String, String>> args = new HashMap<>();
args.put("car1", Collections.singletonMap("color", "blue"));
args.put("car2", Collections.singletonMap("color", "red"));

DittoQueryResult result = (DittoQueryResult) ditto.store.execute(
    "INSERT INTO cars DOCUMENTS (:car1),(:car2)",
    args,
    new Continuation<>() {
        @NonNull
        @Override
        public CoroutineContext getContext() {
            return EmptyCoroutineContext.INSTANCE;
        }

        @Override
        public void resumeWith(@NonNull Object o) {
            if (o instanceof Result.Failure) {
                // Handle failure
            }
        }
    }
);
```
  </Tab>
  <Tab title="C#">
```C#
var args = new Dictionary<string, object>();
args.Add("car1", new { color = "blue" });
args.Add("car2", new { color = "red" });

await ditto.Store.ExecuteAsync(
  "INSERT INTO cars DOCUMENTS (:car1),(:car2)",
  args);
```
  </Tab>
  <Tab title="C++">
```cpp
std::map<std::string, std::map<std::string, std::string>> args;
args["car1"] = {{"color", "blue"}};
args["car2"] = {{"color", "red"}};

auto result = ditto.get_store().execute(
    "INSERT INTO cars DOCUMENTS (:car1),(:car2)",
    args).get();
```
  </Tab>
  <Tab title="Rust">
```Rust
use serde::Serialize;

#[derive(Serialize)]
struct Args {
  newCar: Car,
}
#[derive(Serialize)]
struct Car {
  color: String
}

// ...

let args = Args {
  car1: Car {
    color: "blue".to_string()
  },
  car2: Car {
    color: "red".to_string()
  },
};

ditto.store().execute(
  "INSERT INTO cars DOCUMENTS (:car1),(:car2)",
  Some(args.into()));
```
  </Tab>

</Tabs>

## Supplying a Custom ID

A custom document identifier can be either a string or a JSON-object. JSON-object keys are referred to as _composite identifiers_ because multiple sub-fields together represent the identifier.

Document identifiers are immutable and you can only configure it at the time of document creation.

Once a document is created, to ensure consistency and uniqueness throughout the platform, the unique identifier that either Ditto automatically generated and assigned or you manually assigned becomes permanent and cannot be changed at a later time.

For more information about document IDs, see _Platform Manual_ \> [Document Model](/v4-5/document-model).

### String ID[](#AUph0)

For example, the following snippet demonstrates a new document assigned the custom ID "123".

<Tabs>
  <Tab title="Swift">
```swift
let result = await ditto.store.execute(
  query: "INSERT INTO cars DOCUMENTS (:newCar)",
  arguments: [
    newCar: [ "_id": "123", "color": "blue"]
  ]);

// "123"
print(result.mutatedDocumentIDs()[0])
```
  </Tab>
  <Tab title="Kotlin">
```Kotlin
var result = ditto.store.execute(
  "INSERT INTO cars DOCUMENTS (:newCar)",
  mapOf("newCar" to mapOf("_id" to "123", "color" to "blue")))

// "507f191e810c19729de860ea"
println(result.mutatedDocumentIDs().first())
```
  </Tab>
  <Tab title="JS">
```JS
const newCar = {
  _id: "123",
  color: "blue"
}

const result = await ditto.store.execute(`
  INSERT INTO cars
  DOCUMENTS (:newCar)`,
  { newCar });

// "123"
console.log(result.mutatedDocumentIDs()[0])
```
  </Tab>
  <Tab title="Java">
```Java
Map<String, String> newCar = new HashMap<>();
newCar.put("_id", "123");
newCar.put("color", "blue");

DittoQueryResult result = (DittoQueryResult) ditto.store.execute(
    "INSERT INTO cars DOCUMENTS (:newCar)",
    Collections.singletonMap("newCar", newCar),
    new Continuation<>() {
        @NonNull
        @Override
        public CoroutineContext getContext() {
            return EmptyCoroutineContext.INSTANCE;
        }

        @Override
        public void resumeWith(@NonNull Object o) {
            if (o instanceof Result.Failure) {
                // Handle failure
            }
        }
    }
);

// "123"
System.out.println(result.mutatedDocumentIDs()[0]);
```
  </Tab>
  <Tab title="C#">
```C#
var insertArgs = new Dictionary<string, object>();
insertArgs.Add("newCar", new { _id = "123", color = "blue" });

var result = await ditto.Store.ExecuteAsync(
  "INSERT INTO your_collection_name DOCUMENTS (:newCar)",
  insertArgs);

// "123"
result.MutatedDocumentIds.ForEach(id => Console.WriteLine(id));
```
  </Tab>
  <Tab title="C++">
```cpp
std::map<std::string, std::map<std::string, std::string>> args;
args["newCar"] = {{"_id", "123"},{"color", "blue"}};

auto result = ditto.get_store().execute(
  "INSERT INTO cars DOCUMENTS (:newCar)",
  args).get();

// "123"
std::cout << result.mutated_document_ids()[0].to_string();
```
  </Tab>
  <Tab title="Rust">
```Rust
use serde::Serialize;

#[derive(Serialize)]
struct Args {
  newCar: Car,
}
#[derive(Serialize)]
struct Car {
  _id: String,
  color: String
}

// ...

let args = Args {
  newCar: Car {
    _id: "123".to_string(),
    color: "blue".to_string()
  },
};

let result = ditto.store().execute(
  "INSERT INTO cars DOCUMENTS (:newCar)",
  Some(args.into()));

// "123"
println!("{}", result.mutated_document_ids()[0].to_string())
```
  </Tab>
</Tabs>
Following is the new 123 document that results:

```json Ditto Document
{
  "_id": "123",
  "color": "blue"
}
```
### Composite ID

The following snippet demonstrates combining the vin and make fields to form the composite key:

<Tabs>
  <Tab title="Swift">
```swift
let arguments = [
  newCar: [ "_id": [vin: "123", make: "Toyota"], "color": "blue"]
];

let result = await ditto.store.execute(
  query: "INSERT INTO cars DOCUMENTS (:newCar)",
  arguments: arguments);

// "{vin: "123", make: "Toyota"}"
print(result.mutatedDocumentIDs()[0])
```
  </Tab>
  <Tab title="Kotlin">
```Kotlin
var result = ditto.store.execute(
  "INSERT INTO cars DOCUMENTS (:newCar)",
  mapOf(
    "newCar" to mapOf(
      "_id" to mapOf(
        "vin" to "123",
        "make" to "Toyota"
      ),
      "color" to "blue"
  )))

// "{vin: "123", make: "Toyota"}"
println(result.mutatedDocumentIDs().first())
```
  </Tab>
  <Tab title="JS">
```JS
const newCar = {
  _id: {
    vin: "123",
    make: "Toyota"
  },
  color: "blue"
}
const result = await ditto.store.execute(`
  INSERT INTO cars
  DOCUMENTS (:newCar)`,
  { newCar });

// "{vin: "123", make: "Toyota"}"
console.log(result.mutatedDocumentIDs()[0])
```
  </Tab>
  <Tab title="Java">
```Java
Map<String, String> newCarId = new HashMap<>();
newCarId.put("vin", "123");
newCarId.put("make", "Toyota");
Map<String, Object> newCar = new HashMap<>();
newCar.put("_id", newCarId);
newCar.put("color", "blue");

DittoQueryResult result = (DittoQueryResult) ditto.store.execute(
    "INSERT INTO cars DOCUMENTS (:newCar)",
    Collections.singletonMap("newCar", newCar),
    new Continuation<>() {
        @NonNull
        @Override
        public CoroutineContext getContext() {
            return EmptyCoroutineContext.INSTANCE;
        }

        @Override
        public void resumeWith(@NonNull Object o) {
            if (o instanceof Result.Failure) {
                // Handle failure
            }
        }
    }
);

// "{vin: "123", make: "Toyota"}"
System.out.println(result.mutatedDocumentIDs()[0]);
```
  </Tab>
  <Tab title="C#">
```C#
var newId = new { vin: "123", make: "Toyota"};
var insertArgs = new Dictionary<string, object>();
insertArgs.Add("newCar", new { _id = newId, color = "blue" });

var result = await ditto.Store.ExecuteAsync(
  "INSERT INTO your_collection_name DOCUMENTS (:newCar)",
  insertArgs);

// "{vin: "123", make: "Toyota"}"
result.MutatedDocumentIds.ForEach(id => Console.WriteLine(
  System.Text.Json.JsonSerializer.Serialize(id)));
```
  </Tab>
  <Tab title="C++">
```cpp
var newId = new { vin: "123", make: "Toyota"};
var insertArgs = new Dictionary<string, object>();
insertArgs.Add("newCar", new { _id = newId, color = "blue" });

var result = await ditto.Store.ExecuteAsync(
  "INSERT INTO your_collection_name DOCUMENTS (:newCar)",
  insertArgs);

// "{vin: "123", make: "Toyota"}"
result.MutatedDocumentIds.ForEach(id => Console.WriteLine(
  System.Text.Json.JsonSerializer.Serialize(id)));
```
  </Tab>
  <Tab title="Rust">
```Rust
use serde::Serialize;

#[derive(Serialize)]
struct Args {
  newCar: Car,
}
#[derive(Serialize)]
struct CarId {
  vin: String,
  make: String
}
#[derive(Serialize)]
struct Car {
  _id: CarId,
  color: String
}

// ...

let args = Args {
  newCar: Car {
    _id: CarId {
      vin: "123".to_string(),
      make: "Toyota".to_string()
    },
    color: "blue".to_string()
  },
};

let result = ditto.store().execute(
  "INSERT INTO cars DOCUMENTS (:newCar)",
  Some(args.into()));

// "{vin: "123", make: "Toyota"}"
println!("{}", result.mutated_document_ids()[0].to_string())
```
  </Tab>

</Tabs>
