---
title : Data Structures and Types
---

Ditto stores data in structured JSON-like document objects. Each document consists of sets of human‑readable fields that identify and represent the information the document stores.

## Documents and Collections
Each document is nested with a hash-stable tree structure that self-describes the data to be stored and provides the predetermined rules that ensure data consistency and accuracy.

The following snippet provides an example of a basic JSON-encoded document object:




```json Ditto Document
{ "\_id": "abc123", "make": "Hyundai", "year": 2018, "color": "black" }
```
## FieldsA single document consists of one or more *fields* that self‑describe the data it encodes. Each field is associated with a *value*:

1. *Field* — The name identifying the data. (See [Field Properties](https://docs.ditto.live/v4-5/basics/undefined#Li4_b)﻿)
2. *Value* — The value that holds the actual data to store. (See [Field Values](https://docs.ditto.live/v4-5/basics/undefined#OIk42)﻿)

<Frame>
<img src="/images/v4-5/image-56.png"/>
</Frame>

## Document Identifiers
The first set of fields within each document uniquely identifies the data that its document object encodes. When grouped in a collection, this \_id serves as the primary key identifying the document in the collection.

### Assigning \_id
Ditto automatically generates and assigns each new document a unique identifier, or *\_id*. However, if desired, you can pass your own custom \_id as a parameter when performing an INSERT operation to create a new document. (See [CREATE](https://docs.ditto.live/v4-5/crud-create)﻿)

In addition to having the option to supply your own \_id, in complex scenarios where you want to create a more intricate and unique identifier for your documents, you can combine two or more distinct elements to form a composite key.

For example, the following snippet demonstrates how to create (INSERT) a new document with a composite key formed by the vin, make, and year fields — all of which remain immutable. So, once set at initial document creation, their values cannot be changed.

<Tabs>
    <Tab title="Swift">
    ```
let result = await ditto.store.execute(
  query: "INSERT INTO cars DOCUMENTS (:newCar)",
  arguments: [
    newCar: [ "_id": "123", "color": "blue"]
  ]);

// "123"
print(result.mutatedDocumentIDs()[0])
    ```
    </Tab>
    <Tab title="Kotlin">
    ```
var result = ditto.store.execute(
  "INSERT INTO cars DOCUMENTS (:newCar)",
  mapOf("newCar" to mapOf("_id" to "123", "color" to "blue")))

// "507f191e810c19729de860ea"
println(result.mutatedDocumentIDs().first())
    ```
    </Tab>
    <Tab title="JS">
    ```
const newCar = {
  _id: "123",
  color: "blue"
}

const result = await ditto.store.execute(`
  INSERT INTO cars
  DOCUMENTS (:newCar)`,
  { newCar });

// "123"
console.log(result.mutatedDocumentIDs()[0])
    ```
    </Tab>
    <Tab title="Java">
    ```
Map<String, String> newCar = new HashMap<>();
newCar.put("_id", "123");
newCar.put("color", "blue");

DittoQueryResult result = (DittoQueryResult) ditto.store.execute(
    "INSERT INTO cars DOCUMENTS (:newCar)",
    Collections.singletonMap("newCar", newCar),
    new Continuation<>() {
        @NonNull
        @Override
        public CoroutineContext getContext() {
            return EmptyCoroutineContext.INSTANCE;
        }

        @Override
        public void resumeWith(@NonNull Object o) {
            if (o instanceof Result.Failure) {
                // Handle failure
            }
        }
    }
);

// "123"
System.out.println(result.mutatedDocumentIDs()[0]);
    ```
    </Tab>
    <Tab title="C#">
    ```
var insertArgs = new Dictionary<string, object>();
insertArgs.Add("newCar", new { _id = "123", color = "blue" });

var result = await ditto.Store.ExecuteAsync(
  "INSERT INTO your_collection_name DOCUMENTS (:newCar)",
  insertArgs);

// "123"
result.MutatedDocumentIds.ForEach(id => Console.WriteLine(id));
    ```
    </Tab>
    <Tab title="C++">
    ```
var insertArgs = new Dictionary<string, object>();
insertArgs.Add("newCar", new { _id = "123", color = "blue" });

var result = await ditto.Store.ExecuteAsync(
  "INSERT INTO your_collection_name DOCUMENTS (:newCar)",
  insertArgs);

// "123"
result.MutatedDocumentIds.ForEach(id => Console.WriteLine(id));
    ```
    </Tab>
    <Tab title="Rust">
    ```
use serde::Serialize;

#[derive(Serialize)]
struct Args {
  newCar: Car,
}
#[derive(Serialize)]
struct Car {
  _id: String,
  color: String
}

// ...

let args = Args {
  newCar: Car {
    _id: "123".to_string(),
    color: "blue".to_string()
  },
};

let result = ditto.store().execute(
  "INSERT INTO cars DOCUMENTS (:newCar)",
  Some(args.into()));

// "123"
println!("{}", result.mutated_document_ids()[0].to_string())
    ```
    </Tab>
</Tabs>


<Info>

For more comprehensive information and how-to instructions, see the *Platform Manual* \> [CRUD Operations](https://docs.ditto.live/v4-5/basics/#LBRSIPPkeZdqTGBM4i5NN)﻿.
</Info>

# Data Formatting
As a semi-structured database, data formatting in Ditto is categorized into two main groups:

- *Data Types* — Advanced types that guarantee conflict-free resolution during merging, which includes the REGISTER, MAP, and ATTACHMENT data type. The default data type is REGISTER ; you'll use other data types in specific scenarios where appropriate.
- *Scalar subtypes* — Basic primitive types, such as string and boolean, and the JSON object, which functions as a single value capable of encapsulating multiple key-value pairs.

<Info>
For more information, see the *Platform Manual* \> [Data Types](https://docs.ditto.live/v4-5/data-types)﻿.
</Info>

## Lazy Loading
To improve performance, instead of storing a file that encodes large amounts of binary data within a document, consider storing a reference to it in a separate, explicitly fetched object (token) known as an ATTACHMENT.

With the ATTACHMENT data type, you can implement *lazy loading*. Lazy loading is when you delay retrieval until necessary rather than aggressively fetching the data in anticipation of hypothetical future use. This "on-demand" retrieval pattern enhances performance by optimizing resource usage.

For a realworld usage scenario, see either the demo chat app for iOS or Android in the getditto > [demoapp-chat](https://github.com/getditto/demoapp-chat/tree/main "demoapp-chat") GitHub repository. For instance, in the [iOS demo chat app](https://github.com/getditto/demoapp-chat/tree/main/iOS "iOS demo chat app"), you can see a savvy implementation of ATTACHMENT with a full-resolution avatar image from a collection named User.

## Relationship Models
The following table provides a complete overview of the relationships you can establish in Ditto:

| **Relationship** | **Description** | **Approaches** |
| --- | --- | --- |
| One-to-many | Associates a parent element with children elements to establish a hierarchy. | - Embed a JSON object (REGISTER) - Embed a MAP - Reference a field to a document - Reference a document to a collection |
| Many-to-many | Associates multiple entities in one collection with multiple entities in another collection. | - Embed a JSON object (REGISTER) - Embed a MAP - Create references between documents in different collections |
| Many-to-one | Associates two or more collections, where one collection refers to the primary key of another collection to create a meaningful relationship between the datasets. | - Embed a JSON object (REGISTER) - Embed a MAP - Create references between documents in different collections |

For more information, see *Ditto Basics* > [CRUD Fundamentals](https://docs.ditto.live/v4-5/basics/crud-fundamentals)﻿ and *Platform Manual* \> [CRUD Operations](https://docs.ditto.live/v4-5/basics/#LBRSIPPkeZdqTGBM4i5NN)﻿.
