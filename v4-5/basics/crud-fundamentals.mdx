---
title : CRUD Fundamentals
---

Ditto includes a robust query engine that allows you to perform various filter operations to carry out traditional `create`, `read`, `update`, and `delete` (CRUD) operations.

# Overview

The following tables provides a high-level overview of the different ways you can perform CRUD in Ditto:

| **Operation** | **Description**                                                                                                                                                                 |
| ------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [Create]()    | Using the `upsert` method, either insert a new document or updating an existing document for a given document ID.                                                               |
| [Read]()      | Using either the `find` or `observeLocal` methods, retrieve documents based on the specific criteria you pass as parameters in your function.                                   |
| [Update]()    | Using either `update` or `upsert` methods, write changes to Ditto.                                                                                                              |
| [Delete]()    | Using either `remove` or `evict` methods, delete data in Ditto. In addition, using a _soft-delete pattern_, indicate data as deleted without physically removing it from Ditto. |

<Info>
For detailed information on CRUD, see _Platform Manual_ > [CRUD Operations](<./../Platform Manual/CRUD Operations.md>).

For an overview of the various operators and path navigations you can use to construct sophisticated queries in your app, see _Platform Manual_ > [Query Syntax](<./../Platform Manual/Query Syntax.md>).

</Info>

# Create

Due to Ditto's conflict-free concurrency model, there is no concept of "insert." This is because each peer functions under the assumption that its write transaction already exists somewhere within the mesh network.&#x20;

Therefore, Ditto uses a combined approach known as "upsert." This approach focuses on updating only the fields within the document that have changed, the _delta_. (See [Sync Overview](<./Sync Overview.md>))

If all of the fields in the document are new, however, Ditto creates an entirely new document object. (See _Platform Manual _> [Updating and Upserting](<./../Platform Manual/CRUD Operations.md>))

## Upserting Documents

With the `upsert` method, you can execute any of the following actions in your app:&#x20;

| **Action**                                | **Description**                                                                                                                                                                                                                                                              |
| ----------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Apply delta updates to existing documents | Write changes to only the specific fields within the document that are modified. (See _Platform Manual _> [Upserting Delta Updates](<./../Platform Manual/CRUD Operations/Upserting and Updating.md>).                                                                       |
| Insert a document                         | If all of the fields are new, create a new document object. (See _Platform Manual _> [Creating New Documents](<./../Platform Manual/CRUD Operations/Upserting and Updating.md>))                                                                                             |
| Load initial data                         | Upsert and flag data you want to be accessible to end users at app startup, such as sample chat messages from a central backend API. (See _Platform Manual _> [Example Use Case: Upserting Initial Data](<./../Platform Manual/CRUD Operations/Best Practices for CRUD.md>)) |
| Supply a document ID                      | When creating a new document, if desired, you can assign your own unique identifier. Otherwise, Ditto automatically generates and assigns one for you. (See _Platform Manual _> [Supplying a Custom ID](<./../Platform Manual/CRUD Operations/Upserting and Updating.md>))   |

# Read

To retrieve data in Ditto, depending on your goals and use case, use any of the following query types:

- **Local query** — Using the `find` and `findById` methods, quickly get your own data in a one-time executable to your local Ditto store.&#x20;

  For instance, call the `findById` method to target a specific document. Or if you want to fetch one or more documents based on certain criteria and conditions, call the`find` method instead. (See [Local Queries]())

- **Live query** — Using the `observeLocal` method, establish a listener to observe your local changes in realtime. (See [Live Queries]())

- **Replication query **— Using the `subscribe` method, keep your data consistent with other peers connected in the mesh network. (See [Replication Queries]())

## Local Queries

Similar to a traditional database query, the `find` and `findById` methods are based on a local query that fetches and returns all relevant documents.&#x20;

Intended for quick access to data stored locally on its own device, such as a profile image, local queries are one-time executables that do not involve other peers connected in the mesh network.

For more information and how-to instructions, see _Platform Manual _> [CRUD Operations](<./../Platform Manual/CRUD Operations.md>) and [Finding and Observing](<./../Platform Manual/CRUD Operations/Finding and Observing.md>).

## Live Queries

A live query subscription is essentially a local query, but it includes an `observeLocal` method to establish continuous listening to real-time changes written to its own Ditto store.&#x20;

Live queries are useful when you want to monitor changes from your local Ditto store and react to them immediately. For instance, when your end user updates their own profile, you can asynchronously display the changes to the end user in realtime.

For more information and how-to instructions, see _Platform Manual _> [CRUD Operations](<./../Platform Manual/CRUD Operations.md>) and [Finding and Observing](<./../Platform Manual/CRUD Operations/Finding and Observing.md>).

## Replication Queries

A replication query is executed asynchronously through the `subscribe` method on each remote peer connected within the mesh network.&#x20;

This query specifies the data for which your Small Peer local Ditto store is interested in receiving updates. When remote peers make modifications to the data you've indicated an interest in, they publish the changes back to you — the _subscribing originating peer_.

Rather than continuously polling for updates, which is resource-intensive and generally inefficient, the asynchronous listener you set up triggers only when the data matching your query undergoes changes in the Ditto store.

# Update

The following table provides an overview of the CRDTs and associated behavior for a given operation:

## Updating a Single Document&#x20;

## Updating Multiple Documents

If you want to perform writes to multiple documents, start the transaction asynchronously to avoid blocking the main thread.&#x20;

For example, in Swift, use `DispatchQueue.global`, as demonstrated in the following snippet.

For more information, see the _Platform Manual _> [Best Practices for CRUD](<./../Platform Manual/CRUD Operations/Best Practices for CRUD.md>).

<Tabs>
<Tab title="Swift">
```swift
DispatchQueue.global(qos: .default).async {
    ditto.store.write { transaction in
        let scope = transaction.scoped(toCollectionNamed: "passengers-\(thisFlight)")
        // Loop inside the transaction to avoid writing to database too frequently
        self.passengers.forEach {
            scope.upsert($0.dict)
        }
    }
}
```
</Tab>

<Tab title="Kotlin">
```kotlin
val results = ditto.store.write { transaction ->
    val cars = transaction.scoped("cars")
    val people = transaction.scoped("people")
    val docId = "abc123"
    people.upsert(mapOf("_id" to docId, "name" to "Susan"))
    cars.upsert(mapOf("make" to "Hyundai", "color" to "red", "owner" to docId))
    cars.upsert(mapOf("make" to "Jeep", "color" to "pink", "owner" to docId))
    people.findById(DittoDocumentId(docId)).evict()
}
```
</Tab>

<Tab title="JavaScript">
```javascript
const results = await ditto.store.write(async (transaction) => {
  const cars = transaction.scoped('cars')
  const people = transaction.scoped('people')

// In this example a new person and car document are created, and
// finally the person document that was just created is evicted.
// If any of these operations fail, all others are not applied.
const susanId = await people.upsert({
name: 'Susan',
})
await cars.upsert({
make: 'Hyundai',
color: 'red',
owner: susanId,
})
await people.findByID(susanId).evict()
})

// The return value of a transaction is a list that contains a
// summary of all operations in the transaction and the document IDs
// that were affected:

// results == [
// {
// type: 'inserted',
// docID: DocumentID { ... },
// collectionName: 'people'
// },
// {
// type: 'inserted',
// docID: DocumentID { ... },
// collectionName: 'cars'
// },
// {
// type: 'evicted',
// docID: DocumentID { ... },
// collectionName: 'people'
// }
// ]

````
</Tab>

<Tab title="Java">
```java
DispatchQueue.global(qos: .default).async {
    ditto.store.write { transaction in
        let scope = transaction.scoped(toCollectionNamed: "passengers-\(thisFlight)")
        // Loop inside the transaction to avoid writing to database too frequently
        self.passengers.forEach {
            scope.upsert($0.dict)
        }
    }
}
````

</Tab>

<Tab title="C#">
```csharp
DispatchQueue.global(qos: .default).async {
    ditto.store.write { transaction in
        let scope = transaction.scoped(toCollectionNamed: "passengers-\(thisFlight)")
        // Loop inside the transaction to avoid writing to database too frequently
        self.passengers.forEach {
            scope.upsert($0.dict)
        }
    }
}
```
</Tab>

<Tab title="C++">
```cpp
auto results = ditto.get_store().write([&](WriteTransaction &write_txn) {
  ScopedWriteTransaction people = write_txn.scoped("people");
  ScopedWriteTransaction cars = write_txn.scoped("cars");
  auto docId = "abc123";
  people.upsert({{"name", "Susan"}, {"_id", DocumentId(docId)}});
  cars.upsert({{"make", "Hyundai"}, {"owner", DocumentId(docId)}});
  cars.upsert({{"make", "Toyota"}, {"owner", DocumentId(docId)}});
});
```
</Tab>

<Tab title="Rust">
```rust
DispatchQueue.global(qos: .default).async {
    ditto.store.write { transaction in
        let scope = transaction.scoped(toCollectionNamed: "passengers-\(thisFlight)")
        // Loop inside the transaction to avoid writing to database too frequently
        self.passengers.forEach {
            scope.upsert($0.dict)
        }
    }
}
```
</Tab>
</Tabs>

# Delete

Managing the amount of data stored and replicated across resource-constrained Small Peers interconnected in a bandwidth‑limited mesh is crucial for maintaining optimal performance in a peer‑to‑peer environment.&#x20;

In distributed system architecture, you must strike a balance between data availability and system efficiency:

- The greater the amount of data replicated across connected peers, the more timely offline read access becomes.

- The fewer the number of data replicated across connected peers, the less likelihood that peer devices run out of disk space and experience memory leaks.

## Evict and Remove

Depending on your use case, use either the `evict` or `remove` method to implement memory management practices like automatic resource allocation, memory deallocation, cleaning and maintenance, upon many other tools to help optimize memory usage in your app.&#x20;

### Balancing Syncing and Evicting

Given these technical tradeoffs, use the Subscribe and Eviction methods carefully to implement your tradeoff design decisions:

- To sync more data across peers connected in the mesh, call Subsribe.
- To remove data stored locally on a peer device, call Evict.

Evicting a document is not permanent; as long as there is at least one active subscription with a query that includes an evicted document, that document will reappear as soon as it is available in the mesh.

### Controlling Which Documents Sync

You can signify that data is irrelevant for peer-to-peer replication but should still be retained locally by adding `isSafeToEvict` to the document field property tree.&#x20;

```json
{
  "_id": "abc123",
  "color": "red",
  "mileage": 40000,
  "isSafeToEvict": true,
  "createdAt": "2023-05-22T22:24:24.217Z"
}
```

To ensure that small peers continue syncing documents that are considered relevant, include `isSafeToEvict == false`\*\* \*\*in their subscription queries and then use some means to inform clients to flag any documents that they consider irrelevant.

That way, only the document that a client sets to `'true'` is prevented from syncing.&#x20;

Once flagged, the clients purge the irrelevant documents from their caches, all the while normal transactional operations continue without interruption.

```javascript
collection.find("createdAt > "'2023-05-22T22:24:24.217Z" && isSafeToEvict == false").subscribe()
```

### Permanently Removing Data

The Remove method, once invoked, permanently deletes specified documents from the local datastore as well as all other connected peers.&#x20;

<Warning>
Use the Remove method with extreme caution; invoking Remove results in irreversible data loss. &#x20;
</Warning>

<Tabs>
<Tab title="Swift">
```swift
collection.findByID(docID).remove()
```
</Tab>

<Tab title="Kotlin">
```kotlin
collection.findById(docId).remove()
```
</Tab>

<Tab title="JavaScript">
```javascript
await ditto.store
  .collection("your_collection_name")
  .findByID("unique_document_id")
  .remove()
```
</Tab>

<Tab title="Java">
```java
ditto.store
    .collection("your_collection_name")
    .findByID("unique_document_id")
    .remove();
```
</Tab>

<Tab title="C#">
```csharp
ditto.store
  .Collection("your_collection_name")
  .FindByID("unique_document_id")
  .Remove()
```
</Tab>

<Tab title="C++">
```cpp
ditto.get_store()
  .collection("your_collection_name")
  .find_by_id("unique_document_id")
  .remove()
```
</Tab>

<Tab title="Rust">
```rust
collection.find_by_id(id).remove().unwrap();
```
</Tab>
</Tabs>

## Flagging Soft-Deletes

If you need to ensure that, although deleted, the data remains recoverable, you can add a soft-delete pattern to the document property tree:

<Tabs>
<Tab title="JSON">
```json
{
  "_id": "123abc",
  "name": "Foo",
  "isArchived": true
}
```
</Tab>
</Tabs>

<Info>
For comprehensive information on deleting data in Ditto, see _Platform Manual_ > [Evicting and Removing](<./../Platform Manual/CRUD Operations/Evicting and Removing.md>).
</Info>
