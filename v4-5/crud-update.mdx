---
title: UPDATE
description: This article provides an overview of the updating documents using the UPDATE and INSERT DQL operations.
---

All modification operations in Ditto are performed using the execute API method against the ditto.store:

<Tabs>
  <Tab title="Swift">
```swift
let result = try await ditto.store.execute(query: /* query */, arguments: /* arguments */);
```
  </Tab>
  <Tab title="Kotlin">
```Kotlin
var result = ditto.store.execute(/* query */, /* arguments */)
```
  </Tab>
  <Tab title="JS">
```JS
const result = await ditto.store.execute(/* query */, /* arguments */)
```
  </Tab>
  <Tab title="Java">
```Java
DittoQueryResult result = (DittoQueryResult) ditto.store.execute(
  /* query */,
  /* arguments */,
  /* continuation */);
```
  </Tab>
  <Tab title="C#">
```C#
var result = await ditto.Store.ExecuteAsync(/* query */, /* arguments */);
```
  </Tab>
  <Tab title="C++">
```cpp
auto result = ditto.get_store().execute(/* query */, /* arguments */).get();
```
  </Tab>
  <Tab title="Rust">
```Rust
let result = ditto.store().execute(/* query */, /* arguments */);
```
  </Tab>

</Tabs>

## Updating with UPDATE

Update operations ensure that only the minimum data necessary to enforce all peers converge on one view of the data replicates across the mesh:

<Tabs>
  <Tab title="Swift">
```swift
try await ditto.store.execute("""
  UPDATE cars
  SET color = 'blue'
  WHERE _id = '123'
  """);
```
  </Tab>
  <Tab title="Kotlin">
```Kotlin
ditto.store.execute("""
  UPDATE cars
  SET color = 'blue'
  WHERE _id = '123'
  """)
```
  </Tab>
  <Tab title="JS">
```JS
await ditto.store.execute(`
  UPDATE cars
  SET color = 'blue'
  WHERE _id = '123'`)
```
  </Tab>
  <Tab title="Java">
```Java
DittoQueryResult result = (DittoQueryResult) ditto.store.execute(
  "UPDATE cars SET color = 'blue' WHERE _id = '123'",
  new Continuation<>() {
    @NonNull
    @Override
    public CoroutineContext getContext() {
      return EmptyCoroutineContext.INSTANCE;
    }

    @Override
    public void resumeWith(@NonNull Object o) {
      if (o instanceof Result.Failure) {
        // Handle failure
      }
    }
  }
);
```
  </Tab>
  <Tab title="C#">
```C#
await ditto.Store.ExecuteAsync(
  "UPDATE cars SET color = 'blue' WHERE _id = '123'");
```
  </Tab>
  <Tab title="C++">
```cpp
ditto.get_store().execute(
  "UPDATE cars SET color = 'blue' WHERE _id = '123'").get();
```
  </Tab>
  <Tab title="Rust">
```Rust
ditto.store().execute(
  "UPDATE cars SET color = 'blue' WHERE _id = '123'",
  None);
```
  </Tab>

</Tabs>

## Updating Multiple Documents in a Collection

UPDATE operates over a condition that allows multiple documents to be updated at the same time.

In the following example, all the red cars in the cars collection are updated to be blue. The documents updated can be referenced by using the mutatedDocumentIDs method on the result.
<Tabs>
  <Tab title="Swift">
```swift
let result = try await ditto.store.execute(
  "UPDATE cars SET color = 'blue' WHERE _id = '123'");

result.mutatedDocumentIDs.forEach() { print($0) }
```
  </Tab>
  <Tab title="Kotlin">
```Kotlin
var result = ditto.store.execute("""
  UPDATE cars
  SET color = 'blue'
  WHERE _id = '123'
  """)

result.mutatedDocumentIDs().forEach { id ->
    println(id)
}
```
  </Tab>
  <Tab title="JS">
```JS
const result = await ditto.store.execute(`
  UPDATE cars
  SET color = 'blue'
  WHERE color = 'red'`)

console.log(result.mutatedDocumentIDs())
```
  </Tab>
  <Tab title="Java">
```Java
DittoQueryResult result = (DittoQueryResult) ditto.store.execute(
    "UPDATE cars SET color = 'blue' WHERE color = 'red'",
    new Continuation<>() {
        @NonNull
        @Override
        public CoroutineContext getContext() {
            return EmptyCoroutineContext.INSTANCE;
        }

        @Override
        public void resumeWith(@NonNull Object o) {
            if (o instanceof Result.Failure) {
                // Handle failure
            }
        }
    }
);

for (String id : result.mutatedDocumentIDs()) {
    System.out.println(id);
}
```
  </Tab>
  <Tab title="C#">
```C#
const result = await ditto.Store.ExecuteAsync(
  "UPDATE cars SET color = 'blue' WHERE color = 'red'");

result.MutatedDocumentIDs.ForEach(id => Console.WriteLine(id));
```
  </Tab>
  <Tab title="C++">
```cpp
ditto.get_store().execute(
  "UPDATE cars SET color = 'blue' WHERE color = 'red'").get();
```
  </Tab>
  <Tab title="Rust">
```Rust
ditto.store().execute(
  "UPDATE cars SET color = 'blue' WHERE color = 'red'",
  None);
```
  </Tab>
  <Tab title="Dart">
```Dart
```
  </Tab>
</Tabs>

## Updating with INSERT

The INSERT operation provides conflict policy options to override default behavior if a document with the same ID already exists. By using the ON ID CONFLICT DO UPDATE policy, inserted documents automatically apply updates for all provided fields.

<Warning>
Updating data using an INSERT operation may cause performance to degrade. This is because when you use an INSERT operation to modify data, all provided fields update, even if they remain unchanged.

To optimize performance and reduce unnecessary overhead, apply most updates in your app through the UPDATE method instead.

</Warning>

<Tabs>
  <Tab title="Swift">
```swift
var document = [
  "_id": "123",
  "color": "red",
];

try await ditto.store.execute(
  query:"""
  INSERT INTO cars
  DOCUMENTS (:document)
  ON ID CONFLICT DO UPDATE
  """,
  arguments: [ "document": document ]);
```
  </Tab>
  <Tab title="Kotlin">
```Kotlin
ditto.store.execute(
  "INSERT INTO cars DOCUMENTS (:car)",
  mapOf("car" to mapOf(
    "_id" to "123",
    "color" to "red"
  )))
```
  </Tab>
  <Tab title="JS">
```JS
ditto.store.execute(
  "INSERT INTO cars DOCUMENTS (:car)",
  mapOf("car" to mapOf(
    "_id" to "123",
    "color" to "red"
  )))
```
  </Tab>
  <Tab title="Java">
```Java
Map<String, String> document = new HashMap<>();
newCar.put("_id", "123");
newCar.put("color", "red");

DittoQueryResult result = (DittoQueryResult) ditto.store.execute(
    "INSERT INTO cars DOCUMENTS (:document) ON ID CONFLICT DO UPDATE",
    Collections.singletonMap("document", document),
    new Continuation<>() {
        @NonNull
        @Override
        public CoroutineContext getContext() {
            return EmptyCoroutineContext.INSTANCE;
        }

        @Override
        public void resumeWith(@NonNull Object o) {
            if (o instanceof Result.Failure) {
                // Handle failure
            }
        }
    }
);
```
  </Tab>
  <Tab title="C#">
```C#
var args = new Dictionary<string, object> {
  "document", new { _id = "123" , color = "red" }
};

await ditto.Store.ExecuteAsync(
  "INSERT INTO cars"
+ " DOCUMENTS (:document) ON ID CONFLICT DO UPDATE",
  args);
```
  </Tab>
  <Tab title="C++">
```cpp
std::map<std::string, std::map<std::string, std::string>> args;
args["document"] = {{"_id", "123"},{"color", "red"}};

ditto.get_store().execute(
  "INSERT INTO cars DOCUMENTS (:document) ON ID CONFLICT DO UPDATE",
  args).get();
```
  </Tab>
  <Tab title="Rust">
```Rust
struct Args {
  document: Car,
}
struct Car {
  _id: String,
  color: String
}

// ...

let args = Args {
  document: Car {
    _id: "123".to_string(),
    color: "red".to_string()
  },
};

ditto.store().execute(
  "INSERT INTO cars DOCUMENTS (:document)",
  args);
```
  </Tab>
</Tabs>

For complete DQL syntax, see Ditto Query Language (DQL) > INSERT
