---
titel: READ
description: "This article provides an overview of essential methods for data retrieval."
---

Just like with conventional database querying, you execute query operations to fetch one or more documents that satisfy specific criteria and conditions.

- [Single Execution Queries](/v4-6/crud/read#qXwGV)
- [Store Observer Queries](/v4-6/crud/read#Te8Jg)


## Single Execution Queries
To perform a single execution query on the Ditto store, call the `execute` API method on the `store` namespace as follows:

<Tabs>
    <Tab title="Swift">
    ```swift
    let result = await ditto.store.execute(query: "SELECT * FROM cars")
    ```
    </Tab>
    <Tab title="Kotlin">
    ```kotlin
    val result = ditto.store.execute("SELECT * FROM cars")
    ```
    </Tab>
    <Tab title="JS">
    ```javascript
    const result = await ditto.store.execute("SELECT * FROM cars");
    ```
    </Tab>
    <Tab title="Java">
    ```java
    DittoQueryResult result = (DittoQueryResult) ditto.store.execute(
        "SELECT * FROM cars",
        new Continuation<>() {
            @NonNull
            @Override
            public CoroutineContext getContext() {
                return EmptyCoroutineContext.INSTANCE;
            }

            @Override
            public void resumeWith(@NonNull Object o) {
                if (o instanceof Result.Failure) {
                    // Handle failure
                }
            }
        }
    );
    ```
    </Tab>
    <Tab title="C#">
    ```csharp
    var result = await ditto.Store.ExecuteAsync("SELECT * FROM cars");
    ```
    </Tab>
    <Tab title="C++">
    ```cpp
    auto result = ditto.get_store().execute("SELECT * FROM cars");
    ```
    </Tab>
    <Tab title="Rust">
    ```rust
    auto result = ditto.get_store().execute("SELECT * FROM cars");
    ```
    </Tab>
    <Tab title="Dart">
    ```dart
    auto result = ditto.get_store().execute("SELECT * FROM cars");
    ```
    </Tab>
</Tabs>

## Using args to Query Dynamic Values

When dealing with data that may change dynamically during runtime, instead of defining the changing values directly in the query `string`, encapsulate them in a top-level `args` object you can use to reference the values in your queries.

To pass an argument to the `execute` function, use the `:[argument]` syntax with DQL where the `[argument]` maps to the field in the provided `args` object.

For example, here `color` is passed as an argument to the `execute` function, and, within the query string, `:color` placeholder references the `color` defined in a top-level `args` object.

<Tabs>
    <Tab title="Swift">
    ```swift
    let result = await ditto.store.execute(
      query: "SELECT * FROM cars WHERE color = :color",
      arguments: [ "color": "blue" ])
    ```
    </Tab>
    <Tab title="Kotlin">
    ```kotlin
    val result = ditto.store.execute(
      "SELECT * FROM cars WHERE color = :color",
      mapOf("color" to "blue"))
    ```
    </Tab>
    <Tab title="JS">
    ```javascript
    const result = await ditto.store.execute(
      "SELECT * FROM cars WHERE color = :color",
      { color: "blue" }
    );
    ```
    </Tab>
    <Tab title="Java">
    ```java
    DittoQueryResult result = (DittoQueryResult) ditto.store.execute(
        "SELECT * FROM cars WHERE color = :color",
        Collections.singletonMap("color", "blue"),
        new Continuation<>() {
            @NonNull
            @Override
            public CoroutineContext getContext() {
                return EmptyCoroutineContext.INSTANCE;
            }

            @Override
            public void resumeWith(@NonNull Object o) {
                if (o instanceof Result.Failure) {
                    // Handle failure
                }
            }
        }
    );
    ```
    </Tab>
    <Tab title="C#">
    ```csharp
    const result = await ditto.Store.ExecuteAsync(
      "SELECT * FROM cars WHERE color = :color",
      new Dictionary<string, object> { "color", "blue" });
    ```
    </Tab>
    <Tab title="C++">
    ```cpp
    auto result = ditto.get_store().execute(
      "SELECT * FROM cars WHERE color = :color",
      {{"color", "blue"}});
    ```
    </Tab>
    <Tab title="Rust">
    ```rust
    struct Args {
        color: String,
    }

    //...

    let args = Args {
        color: "blue".to_string(),
    };

    let result = ditto.store().execute(
      "SELECT * FROM cars WHERE color = :color",
      Some(args.into()));
    ```
    </Tab>
    <Tab title="Dart">
    ```dart
    final result = await ditto.store.execute(
      "SELECT * FROM cars WHERE color = :color",
      arguments: {"color": "blue"});
    ```
    </Tab>
</Tabs>

Once the previous example operation executes, the query becomes `SELECT * FROM cars WHERE color = blue`.

## Managing Query Results

After executing a query, the `result` object that is returned includes both the overall content retrieved and individual items. Each item is encapsulated in independent `QueryResultItem` objects that you can use to access them either directly or as raw CBOR or JSON data.

Rather than retrieving the items as part of the query execution and making them available immediately after execution, each item is *lazy loaded*. Lazy loading involves postponing fetching and storing in memory until requested on-demand or accessed later.

Here is an example query execution to select all documents from the `cars` collection. The result is stored in the variable result. Then, each item is lazy loaded from the result object and stored in the `items`:

<Tabs>
    <Tab title="Swift">
    ```swift
    let result = await ditto.store.execute(query: "SELECT * FROM cars")

    let items = result.items
    ```
    </Tab>
    <Tab title="Kotlin">
    ```kotlin
    val result = ditto.store.execute("SELECT * FROM cars")

    const items = result.items
    ```
    </Tab>
    <Tab title="JS">
    ```javascript
    const result = await ditto.store.execute("SELECT * FROM cars")

    const items = result.items
    ```
    </Tab>
    <Tab title="Java">
    ```java
    DittoQueryResult result = (DittoQueryResult) ditto.store.execute(
        "SELECT * FROM cars",
        new Continuation<>() {
            @NonNull
            @Override
            public CoroutineContext getContext() {
                return EmptyCoroutineContext.INSTANCE;
            }

            @Override
            public void resumeWith(@NonNull Object o) {
                if (o instanceof Result.Failure) {
                    // Handle failure
                }
            }
        }
    );

    DittoQueryResultItems items = result.items;
    ```
    </Tab>
    <Tab title="C#">
    ```csharp
    var result = await ditto.Store.ExecuteAsync("SELECT * FROM cars");

    var items = result.Items;
    ```
    </Tab>
    <Tab title="C++">
    ```cpp
    auto result = ditto.get_store().execute("SELECT * FROM cars");

    auto items = result.items();
    ```
    </Tab>
    <Tab title="Rust">
    ```rust
    let result = ditto.store().execute("SELECT * FROM cars", None);

    let items = result.items();
    ```
    </Tab>
    <Tab title="Dart">
    ```dart
    final result = await ditto.store.execute("SELECT * FROM cars");

    final items = result.items;
    ```
    </Tab>
</Tabs>

## Working with a QueryResultItem

The result `items` object is a collection of`QueryResultItem`. Each item's value can be independently managed to meet the needs of your scenario.

### Value

To retrieve the value, call the `value` property on an item:

<Tabs>
    <Tab title="Swift">
    ```swift
    let result = await ditto.store.execute(query: "SELECT * FROM cars")

    let item = result.items[0]
    let itemValue = item.value
    let itemValueColor = item.value["color"]
    ```
    </Tab>
    <Tab title="Kotlin">
    ```kotlin
    val result = ditto.store.execute("SELECT * FROM cars")

    val item = result.items.first()
    val itemValue = item.value
    val itemValueColor = item.value["color"]
    ```
    </Tab>
    <Tab title="JS">
    ```javascript
    const result = await ditto.store.execute(`SELECT * FROM cars`)

    const item = result.items[0]
    const itemValue = item.value
    const itemValueColor = item.value["color"]
    ```
    </Tab>
    <Tab title="Java">
    ```java
    DittoQueryResult result = (DittoQueryResult) ditto.store.execute(
        "SELECT * FROM cars",
        new Continuation<>() {
            @NonNull
            @Override
            public CoroutineContext getContext() {
                return EmptyCoroutineContext.INSTANCE;
            }

            @Override
            public void resumeWith(@NonNull Object o) {
                if (o instanceof Result.Failure) {
                    // Handle failure
                }
            }
        }
    );

    DittoQueryResultItem item = result.items[0]
    Map<String, Object> itemValue = item.value
    String itemValueColor = item.value["color"].toString()
    ```
    </Tab>
    <Tab title="C#">
    ```csharp
    var result = await ditto.Store.ExecuteAsync("SELECT * FROM cars");

    var item = result.Items[0];
    var itemValue = item.Value;
    var itemValueColor = item.Value["color"] as string;
    ```
    </Tab>
    <Tab title="C++">
    ```cpp
    const auto result = ditto.store.execute(`SELECT * FROM cars`);

    auto item = result.get_item(0);
    auto item_value = item.value();
    auto item_value_color = item_value["color"];
    ```
    </Tab>
    <Tab title="Rust">
    ```rust
    let result = ditto.store().execute("SELECT * FROM cars", None);

    let item = result.items(0);
    let itemValue = item.materialize();
    ```
    </Tab>
    <Tab title="Dart">
    ```dart
    final result = await ditto.store.execute("SELECT * FROM cars");

    final item = result.items[0];
    final itemValue = item.value;
    final itemValueColor = item.value["color"];
    ```
    </Tab>
</Tabs>

### Materializing the Value

To help manage memory usage more efficiently, content associated with an `item` is lazily loaded, meaning it materializes — loads into memory — only upon the initial call to `value`.

To load the item's value into memory, use any of the following methods as appropriate:

<Tabs>
    <Tab title="Swift">
    ```swift
    // Returns `true` if value is currently held materialized in memory, otherwise returns `false`
    item.isMaterialized

    // Loads the item's value into memory
    item.materialize()

    // Release item's value from memory
    item.dematerialize()
    ```
    </Tab>
    <Tab title="Kotlin">
    ```kotlin
    // Returns `true` if value is currently held materialized in memory, otherwise returns `false`
    item.isMaterialized

    // Loads the item's value into memory
    item.materialize()

    // Release item's value from memory
    item.dematerialize()
    ```
    </Tab>
    <Tab title="JS">
    ```javascript
    // Returns `true` if value is currently held materialized in memory, otherwise returns `false`
    item.isMaterialized

    // Loads the item's value into memory
    item.materialize()

    // Release item's value from memory
    item.dematerialize()
    ```
    </Tab>
    <Tab title="Java">
    ```java
    // Returns `true` if value is currently held materialized in memory, otherwise returns `false`
    item.isMaterialized

    // Loads the item's value into memory
    item.materialize()

    // Release item's value from memory
    item.dematerialize()
    ```
    </Tab>
    <Tab title="C#">
    ```csharp
    // Returns `true` if value is currently held materialized in memory, otherwise returns `false`
    item.IsMaterialized;

    // Loads the item's value into memory
    item.Materialize();

    // Release item's value from memory
    item.Dematerialize();
    ```
    </Tab>
    <Tab title="C++">
    ```cpp
    // Returns `true` if value is currently held materialized in memory, otherwise returns `false`
    item.is_materialized()

    // Loads the item's value into memory
    item.materialize()

    // Release item's value from memory
    item.dematerialize()
    ```
    </Tab>
    <Tab title="Rust">
    ```rust
    // Loads the item's value into memory
    item.materialize();
    ```
    </Tab>
    <Tab title="Dart">
    ```dart
    // Query results are always materialized in Dart
    ```
    </Tab>
</Tabs>

### Raw CBOR Value

To access the result items as CBOR data:

<Info>
The result of this method call is not cached.
</Info>

<Tabs>
    <Tab title="Swift">
    ```swift
    let result = await ditto.store.execute(query: "SELECT * FROM cars")

    let cborSerializedItem = result.items[0].cborData()
    ```
    </Tab>
    <Tab title="Kotlin">
    ```kotlin
    val result = ditto.store.execute("SELECT * FROM cars")

    val cborItem = result.items.first().cborData()
    ```
    </Tab>
    <Tab title="JS">
    ```javascript
    const result = await ditto.store.execute(`SELECT * FROM cars`)

    const cborItem = result.items[0].cborData()
    ```
    </Tab>
    <Tab title="Java">
    ```java
    DittoQueryResult result = (DittoQueryResult) ditto.store.execute(
        "SELECT * FROM cars",
        new Continuation<>() {
            @NonNull
            @Override
            public CoroutineContext getContext() {
                return EmptyCoroutineContext.INSTANCE;
            }

            @Override
            public void resumeWith(@NonNull Object o) {
                if (o instanceof Result.Failure) {
                    // Handle failure
                }
            }
        }
    );

    byte[] cborItem = result.items[0].cborData()
    ```
    </Tab>
    <Tab title="C#">
    ```csharp
    var result = await ditto.Store.ExecuteAsync("SELECT * FROM cars");

    var cborItem = result.Items[0].CborData();
    ```
    </Tab>
    <Tab title="C++">
    ```cpp
    auto result = ditto.get_store().execute("SELECT * FROM cars");

    auto cborItem = result.get_item(0).cbor_data();
    ```
    </Tab>
    <Tab title="Rust">
    ```rust
    let result = ditto.store().execute("SELECT * FROM cars", None);

    let cborItem = result.items(0).cbor();
    ```
    </Tab>
    <Tab title="Dart">
    ```dart
    // Coming Soon
    ```
    </Tab>
</Tabs>

### Raw JSON Value

To access the result items as a JSON-string:

<Info>
The result of this method call is not cached.
</Info>

<Tabs>
    <Tab title="Swift">
    ```swift
    let result = await ditto.store.execute(query: "SELECT * FROM cars")

    let jsonSerializedItem: String = result.items[0].jsonString()

    let jsonAsData: Data = Data(jsonSerializedItem.utf8)
    ```
    </Tab>
    <Tab title="Kotlin">
    ```kotlin
    val result = ditto.store.execute("SELECT * FROM cars")

    val jsonItem = result.items.first().jsonString()
    ```
    </Tab>
    <Tab title="JS">
    ```javascript
    const result = await ditto.store.execute(`SELECT * FROM cars`)

    const jsonItem = result.items[0].jsonString()
    ```
    </Tab>
    <Tab title="Java">
    ```java
    DittoQueryResult result = (DittoQueryResult) ditto.store.execute(
        "SELECT * FROM cars",
        Collections.singletonMap("color", "blue"),
        new Continuation<>() {
            @NonNull
            @Override
            public CoroutineContext getContext() {
                return EmptyCoroutineContext.INSTANCE;
            }

            @Override
            public void resumeWith(@NonNull Object o) {
                if (o instanceof Result.Failure) {
                    // Handle failure
                }
            }
        }
    );

    String cborItem = result.items[0].jsonData()
    ```
    </Tab>
    <Tab title="C#">
    ```csharp
    var result = await ditto.Store.ExecuteAsync("SELECT * FROM cars");

    var jsonItem = result.Items[0].JsonString();
    ```
    </Tab>
    <Tab title="C++">
    ```cpp
    auto result = ditto.get_store().execute("SELECT * FROM cars");

    auto jsonItem = result.get_item(0).json_string();
    ```
    </Tab>
    <Tab title="Rust">
    ```rust
    let result = ditto.store().execute("SELECT * FROM cars", None);

    let jsonItem = result.items(0).json();
    ```
    </Tab>
    <Tab title="Dart">
    ```dart
    // Coming Soon
    ```
    </Tab>
</Tabs>


## Store Observer Queries

A *store observer* is a DQL query that runs continuously and triggers a callback when a change to the store impacts the results of the query.

Store observers are useful when you want to monitor changes from your local Ditto store and react to them immediately. For instance, when your end user updates their profile, asynchronously display changes in realtime.

## Setting Up Store Observers

Using the `registerObserver` method, set up an observer within the `store` namespace enclosed with a query that specifies the collection to watch for changes, as well as your logic to handle the incoming changes.

<Tabs>
  <Tab title="Swift">
```swift
let observer = ditto.store.registerObserver(
  query: "SELECT * FROM cars"){ result in /* handle change */ };
```
  </Tab>
  <Tab title="Kotlin">
```Kotlin
val observer = ditto.store.registerObserver("SELECT * FROM cars") { result ->
  /* handle change */ };
```
  </Tab>
  <Tab title="JS">
```JS
const changeHandler = (result) => {
  // handle change
}
const observer = ditto.store.registerObserver(
  "SELECT * FROM cars",
  changeHandler);
```
  </Tab>
  <Tab title="Java">
```Java
DittoStoreObserver observer = ditto.store.registerObserver(
    "SELECT * FROM cars",
    result -> {
        // handle change
    }
);
```
  </Tab>
  <Tab title="C#">
```C#
// Without Arguments
var result = await ditto.Store.RegisterObserver(
  "SELECT * FROM cars",
  (result) => {
    // handle change
  });

// With Arguments
var result = ditto.Store.RegisterObserver(
  "SELECT * FROM cars",
  (result) => {
    // handle change
  });
```
  </Tab>
  <Tab title="C++">
```cpp
auto observer = ditto.get_store().register_observer(
  "SELECT * FROM cars",
  [&](QueryResult result) { /* handle change */ });
```
  </Tab>
  <Tab title="Rust">
```Rust
let observer = ditto.store().register_observer(
  "SELECT * from cars",
  None,
  move |result: QueryResult| {
    // handle change
  })
```
  </Tab>
</Tabs>

### Associating Arguments

To associate arguments with your query

:::codeblocktabs
```swift
let observer = ditto.store.registerObserver(
  query: "SELECT * FROM cars WHERE color = :color",
  argumets: [ "color": "blue" ]){ result in /* handle change */ };
```

```kotlin
ditto.store.registerObserver(
  "SELECT * FROM cars WHERE color = :color",
  mapOf("color" to "blue")) { result ->
  /* handle change */ };
```

```javascript
const changeHandler = (result) => {
  // handle change
}
const observer = ditto.store.registerObserver(
  "SELECT * FROM cars WHERE color = :color",
  changeHandler,
  { color: 'blue' });
```

```java
DittoStoreObserver observer = ditto.store.registerObserver(
    "SELECT * FROM cars WHERE color = :color",
    Collections.singletonMap("color", "blue"),
    result -> {
        // handle change
    }
);
```

```csharp
// Without Arguments
var result = await ditto.Store.RegisterObserver(
  "SELECT * FROM cars",
  (result) => {
    // handle change
  });

// With Arguments
var result = ditto.Store.RegisterObserver(
  "SELECT * FROM cars WHERE color = :color",
  new Dictionary<string, object> { "color", "blue" },
  (result) => {
    // handle change
  });

```

```cpp
auto observer = ditto.get_store().register_observer(
  "SELECT * FROM cars",
  {{"color", "blue"}}),
  [&](QueryResult result) { /* handle change */ });
```

```rust
struct Args {
    color: String,
}

//...

let args = Args {
    color: "blue".to_string(),
}

let observer = ditto.store().register_observer(
  "SELECT * from cars WHERE color = :color",
  args,
  move |result: QueryResult| {
    // handle change
  })
```
:::

## Canceling a Store Observer

To cancel a store observer, call `cancel` on the observer object.

Once canceled, the store observer will stop processing in the background and will no longer call the provided callback.

<Tabs>
  <Tab title="Swift">
    ```swift
    observer.cancel()
    ```
  </Tab>
  <Tab title="Kotlin">
    ```kotlin
    observer.cancel()
    ```
  </Tab>
  <Tab title="JS">
    ```javascript
    observer.cancel()
    ```
  </Tab>
  <Tab title="Java">
    ```java
    observer.cancel();
    ```
  </Tab>
  <Tab title="C#">
    ```csharp
    observer.Cancel()
    ```
  </Tab>
  <Tab title="C++">
    ```cpp
    observer.cancel();
    ```
  </Tab>
  <Tab title="Rust">
    ```rust
    observer.cancel()
    ```
  </Tab>
</Tabs>

## Accessing Store Observers

To access store observers from the local Ditto store:

<Tabs>
  <Tab title="Swift">
    ```swift
    ditto.store.observers
    ```
  </Tab>
  <Tab title="Kotlin">
    ```kotlin
    ditto.store.observers
    ```
  </Tab>
  <Tab title="JS">
    ```javascript
    ditto.store.observers
    ```
  </Tab>
  <Tab title="Java">
    ```java
    ditto.store.observers;
    ```
  </Tab>
  <Tab title="C#">
    ```csharp
    ditto.Store.Observers
    ```
  </Tab>
  <Tab title="C++">
    ```cpp
    ditto.get_store().observers()
    ```
  </Tab>
  <Tab title="Rust">
    ```rust
    ditto.store().observers()
    ```
  </Tab>
</Tabs>
