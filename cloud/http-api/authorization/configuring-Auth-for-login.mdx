---
title: Configuring Auth for login
description: This article will require knowledge of writing server side HTTP endpoints and handlers.
icon: key
iconType: solid
---

The server side sample code is written in JavaScript (NodeJS with an <a href="https://expressjs.com/" target="_blank">Express</a>-like API), however you can use any framework or language of your choosing.

We will use Auth0 in this tutorial. But you can use any third-party identity provider. Each app can use multiple identity providers.

In this tutorial, you'll build a simple application so users can log in with a a third-party provider using <a href="https://auth0.com/" target="_blank">Auth0</a>. We assume that you have already completed the Auth0 tutorial on their documentation before starting this tutorial.

For the full application code in JavaScript and Swift, see the <a href="https://github.com/getditto/examples-permission" target="_blank">code samples on GitHub</a>.

## Configuring Ditto

To use an "Online With Authentication" identity, go to your app in the <a href="https://portal.ditto.live/" target="_blank">portal</a> and find the **Authentication Mode & Webhook Settings** section. Ensure that **"With Authentication"** is selected like so:

<Frame>
  <img src="https://archbee-image-uploads.s3.amazonaws.com/qoRkNxW5fJ81r_NqVpc8C/qn9kmoIFIbZmWLSpecLoL_image.png"/>
</Frame>

Below, a section called **Authentication Webhooks** will be editable. Once your Authentication Webhook Endpoint(s) is deployed and ready, you can register it in the portal. Add a **Name** and **URL**.

- Provide a unique **Name** to identify your authentication WebHooks.
- The **URL** parameter is the fully qualified URL of the webhook that you deploy yourself. Please include https\:// at the beginning of your URL.

You can use our example webhook to just get started. This webhook is a server deployed on a third-party server and is just for testing. This server will always authorize all clients with full read and write permissions.

You can use this URL to test your application. However, you should not use this URL in production. This Replit simply authenticates everyone for 7 days of offline usage.
<Card
  title="https://alloweveryonewebhook.tester28.repl.co/auth"
  icon="link"
  href="https://alloweveryonewebhook.tester28.repl.co/auth"
  iconType="solid"
  horizontal
/>

Once configured, you should see a webhook that looks like this in your portal app settings:

<Frame>
  ![](https://archbee-image-uploads.s3.amazonaws.com/qoRkNxW5fJ81r_NqVpc8C/oGRAE42LN2cQVelhvUESw_image.png)
</Frame>

### Configuring Auth0

The second step is to configure Auth0. Follow these steps:

1. Create a new Auth0 application.
2. Configure the allowed callbacks and origins for your application. Make sure to add the callback URL for your application.
3. Configure the allowed grant types for your application. For this tutorial, we will use the "Authorization Code" grant type.
4. Create a new API in Auth0. This will represent the API that your application will access.

Next, you need to configure Ditto. Follow the steps that were outlined earlier in this article.

Now that you have configured Auth0 and Ditto, you can start integrating them into your application.

**If you already have an Auth0 account...**[**​**](https://legacydocs.ditto.live/http/common/security/authentication#if-you-already-have-an-auth0-account)[​](https://legacydocs.ditto.live/http/common/security/authentication#configure-auth0)

...log in, skip the next section, and proceed to the part titled ***Register your app with Auth0***.

...you can <a href="https://auth0.com/signup" target="_blank">sign up for one here</a> - it's free.

In the menu on the left side of the Auth0 dashboard, click **Applications**:

<Frame>
  ![](https://archbee-image-uploads.s3.amazonaws.com/qoRkNxW5fJ81r_NqVpc8C/xZGJtspvJXsRy_wsOW5B__image.png)
</Frame>

This will expand the **Applications** menu. Select the first item in that menu, which also has the name **Applications.**

You will now be on the **Applications** page. It lists all the applications that you have registered so that Auth0 can handle their login/logout processes.


Create a new registration for your app. Do this by clicking the Create application button near the top right of the page.

You can follow the prompts and instructions on the Auth0 site for more details. From the Auth0 portal you will need to retrieve the following information for your Android app:

- Domain
- Client ID

You can store these as String resources in your app. On the Auth0 portal, you will need to build your callback URL and logout URL. Again, see the Auth0 website for details on how to do this.

### References

<a href="https://auth0.com/blog/get-started-with-android-authentication-using-kotlin-part-1/" target="_blank">Auth0 Tutorial</a>

<a href="https://manage.auth0.com/dashboard/us/dev-voiik8orqv6m487g/onboarding" target="_blank">Auth0 Website - Android Getting Started / Onboarding</a>

## Integrating Auth0 with Ditto[​](https://legacydocs.ditto.live/http/common/security/authentication#integrating-auth0-with-ditto)

Assuming you have a login button in the HTML:

```html
<button onClick={login}>Login</button>
```

We attach a `login` function to the button.

```javascript
import createAuth0Client from '@auth0/auth0-spa-js';
// OR for React
import { useAuth0 } from '@auth0/auth0-react';

// configure your auth0 client...

async function login () {
  await auth0.loginWithRedirect({
    redirect_uri: window.location.origin
  });
  startDitto()
}
```

We can then create a `startDitto` function that gets the access token and starts a new Ditto instance, and passes the token to your server route you created in the previous section.

<Info>
The provider name given to the Ditto Client must match a provider name in the Portal (e.g., `replit-auth`).

</Info>


```javascript
import createAuth0Client from '@auth0/auth0-spa-js';
// OR for React
import { useAuth0 } from '@auth0/auth0-react';
import { init, Ditto } from "@dittolive/ditto"

// configure your auth0 client...

let ditto

(async () => {
  await init() // you need to call this at least once before using any of the Ditto API

  function startDitto () {
    let token = await auth0.getAccessTokenSilently();

    const authHandler = {
      authenticationRequired: async function(authenticator) {
        await authenticator.login(token, "replit-auth");
        console.log("Login request completed.");
      },
      authenticationExpiringSoon: function(authenticator, secondsRemaining) {
        console.log(`Auth token expiring in ${secondsRemaining} seconds`)
        await authenticator.login(token, "replit-auth");
        console.log("Login request completed.");
      }
    }

    const identity = {
      type: 'onlineWithAuthentication',
      appID: 'REPLACE_ME_WITH_YOUR_APP_ID',
      authHandler
    }

    ditto = new Ditto(identity, '/persistence/file/path')
    ditto.startSync()
  }

  async function login () {
    await auth0.loginWithRedirect({
      redirect_uri: window.location.origin
    });
    startDitto()
  }
})()
```

To demonstrate that this Ditto client has been authenticated, let's display the number of cars in the collection, and a button to add one item to it:

```html
<div>
  <h1>Cars: {numberOfCars}</h1>
  <button onClick={addItem}>+1</button>
</div>
```

Once we start the ditto instance, we can create a **liveQuery** and create a button that adds items to a collection:

```javascript
let subscription = ditto.store.collection('cars').find("state == 'FOR_SALE'").subscribe()
let liveQuery = ditto.store.collection('cars').find("name == 'Toyota'").observeLocal((cars) => {
  numberOfCars = cars.length
})

function addItem () {
  ditto.store.collection('cars').upsert({
    "name": 'Toyota',
    "state": 'FOR_SALE'
  })
}
```

## Log Out

```javascript
let loggedIn = false
if (auth0.isAuthenticated()) {
  loggedIn = true
}
```

```javascript
if (loggedIn) {
  // render the logout button
  <button onClick={onLogoutClick}>Logout</button>
} else {
  <button onClick={login}>Login</button>
}
```

To make this usable for real-world applications, you can retrieve the user's profile details such as email, username, and full name. See the official Auth0 documentation for your platform to add that functionality to your application.

## Server

The authentication webhook needs to handle an HTTP POST request. Each client that will need to authenticate will send a payload to this webhook. The following section requires that you have knowledge of writing server side HTTP endpoints and responding with a JSON payload. Code samples of server side code are written with a NodeJS / Express syntax. You can use any language or framework on the server side.

### **Incoming POST Body**[**​**](https://legacydocs.ditto.live/http/common/security/authentication#incoming-post-body)

When your client device wants to authenticate using your webhook, your server will receive an HTTP post with a JSON payload that looks like:


```curl cURL
{
  "appID": "YOUR_APP_ID_HERE", // the appID
  "provider": "my-auth", // this is the "Name" of the "Authentication     Webhook"
  "token": "eyJhbGciOiJI..." // this is what each device will send to authenticate
}
```


Your can introspect these values by parsing out the request body:

```javascript JS
let express = require('express')
let cors = require('cors')
let body = require('body-parser')
let app = express()

app.use(cors())
app.use(body.json())

let app = express()

app.post('/', (req, res) => {
  const appID = req.body.appID
  const provider = req.body.provider
  const token = req.body.token
})
```

Generally, you will want to check the token for some sort of validity. Let's assume you have some sort of library or logic to parse and validate the token is for a specific user.

You can also use the `clientInfo` key in your JSON response to pass information back to client.

```javascript JS
app.post('/', async (req, res) => {
  const token = req.body.token;
  try {
    // The token that your server receives from ditto is always a string
    let parsedToken = JSON.parse(token)
    let payload = getDittoPermissions(parsedToken)
    res.json(payload)
  } catch (err) {
    res.json({
      "authenticate": err,
      "clientInfo": err.message
    })
  }
})
```

As a simple example, let's grant full read and write permissions to all collections and all documents.

```javascript JS
app.post('/', async (req, res) => {
  const token = req.body.token;
  try {
    let payload = {
      "authenticate": true,
      "expirationSeconds": 28800,
      "userID": "123abc",
      "permissions": {
        "read": {
          "everything": true,
          "queriesByCollection": {}
        },
        "write": {
          "everything": true,
          "queriesByCollection": {}
        }
      }
    }
    res.json(payload)
  } catch (err) {
    res.json({
      "authenticate": err,
      "clientInfo": err.message
    })
  }
})
```
