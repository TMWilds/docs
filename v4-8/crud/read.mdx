---
titel: READ
description: "This article provides an overview of essential methods for data retrieval."
---

Just like with conventional database querying, you execute query operations to fetch one or more documents that satisfy specific criteria and conditions.

To perform a single execution query on the Ditto store, call the `execute` API method on the `store` namespace as follows:

<Tabs>
    <Tab title="Swift">
    ```swift
    let result = await ditto.store.execute(query: "SELECT * FROM cars")
    ```
    </Tab>
    <Tab title="Kotlin">
    ```kotlin
    val result = ditto.store.execute("SELECT * FROM cars")
    ```
    </Tab>
    <Tab title="JS">
    ```javascript
    const result = await ditto.store.execute("SELECT * FROM cars");
    ```
    </Tab>
    <Tab title="Java">
    ```java
    DittoQueryResult result = (DittoQueryResult) ditto.store.execute(
        "SELECT * FROM cars",
        new Continuation<>() {
            @NonNull
            @Override
            public CoroutineContext getContext() {
                return EmptyCoroutineContext.INSTANCE;
            }

            @Override
            public void resumeWith(@NonNull Object o) {
                if (o instanceof Result.Failure) {
                    // Handle failure
                }
            }
        }
    );
    ```
    </Tab>
    <Tab title="C#">
    ```csharp
    var result = await ditto.Store.ExecuteAsync("SELECT * FROM cars");
    ```
    </Tab>
    <Tab title="C++">
    ```cpp
    auto result = ditto.get_store().execute("SELECT * FROM cars");
    ```
    </Tab>
    <Tab title="Rust">
    ```rust
    auto result = ditto.get_store().execute("SELECT * FROM cars");
    ```
    </Tab>
    <Tab title="Dart">
    ```dart
    auto result = ditto.get_store().execute("SELECT * FROM cars");
    ```
    </Tab>
</Tabs>

## Using args to Query Dynamic Values

When dealing with data that may change dynamically during runtime, instead of defining the changing values directly in the query `string`, encapsulate them in a top-level `args` object you can use to reference the values in your queries.

To pass an argument to the `execute` function, use the `:[argument]` syntax with DQL where the `[argument]` maps to the field in the provided `args` object.

For example, here `color` is passed as an argument to the `execute` function, and, within the query string, `:color` placeholder references the `color` defined in a top-level `args` object.

<Tabs>
    <Tab title="Swift">
    ```swift
    let result = await ditto.store.execute(
      query: "SELECT * FROM cars WHERE color = :color",
      arguments: [ "color": "blue" ])
    ```
    </Tab>
    <Tab title="Kotlin">
    ```kotlin
    val result = ditto.store.execute(
      "SELECT * FROM cars WHERE color = :color",
      mapOf("color" to "blue"))
    ```
    </Tab>
    <Tab title="JS">
    ```javascript
    const result = await ditto.store.execute(
      "SELECT * FROM cars WHERE color = :color",
      { color: "blue" }
    );
    ```
    </Tab>
    <Tab title="Java">
    ```java
    DittoQueryResult result = (DittoQueryResult) ditto.store.execute(
        "SELECT * FROM cars WHERE color = :color",
        Collections.singletonMap("color", "blue"),
        new Continuation<>() {
            @NonNull
            @Override
            public CoroutineContext getContext() {
                return EmptyCoroutineContext.INSTANCE;
            }

            @Override
            public void resumeWith(@NonNull Object o) {
                if (o instanceof Result.Failure) {
                    // Handle failure
                }
            }
        }
    );
    ```
    </Tab>
    <Tab title="C#">
    ```csharp
    const result = await ditto.Store.ExecuteAsync(
      "SELECT * FROM cars WHERE color = :color",
      new Dictionary<string, object> { "color", "blue" });
    ```
    </Tab>
    <Tab title="C++">
    ```cpp
    auto result = ditto.get_store().execute(
      "SELECT * FROM cars WHERE color = :color",
      {{"color", "blue"}});
    ```
    </Tab>
    <Tab title="Rust">
    ```rust
    struct Args {
        color: String,
    }

    //...

    let args = Args {
        color: "blue".to_string(),
    };

    let result = ditto.store().execute(
      "SELECT * FROM cars WHERE color = :color",
      Some(args.into()));
    ```
    </Tab>
    <Tab title="Dart">
    ```dart
    final result = await ditto.store.execute(
      "SELECT * FROM cars WHERE color = :color",
      arguments: {"color": "blue"});
    ```
    </Tab>
</Tabs>

Once the previous example operation executes, the query becomes `SELECT * FROM cars WHERE color = blue`.

## Managing Query Results

After executing a query, the `result` object that is returned includes both the overall content retrieved and individual items. Each item is encapsulated in independent `QueryResultItem` objects that you can use to access them either directly or as raw CBOR or JSON data.

Rather than retrieving the items as part of the query execution and making them available immediately after execution, each item is *lazy loaded*. Lazy loading involves postponing fetching and storing in memory until requested on-demand or accessed later.

Here is an example query execution to select all documents from the `cars` collection. The result is stored in the variable result. Then, each item is lazy loaded from the result object and stored in the `items`:

<Tabs>
    <Tab title="Swift">
    ```swift
    let result = await ditto.store.execute(query: "SELECT * FROM cars")

    let items = result.items
    ```
    </Tab>
    <Tab title="Kotlin">
    ```kotlin
    val result = ditto.store.execute("SELECT * FROM cars")

    const items = result.items
    ```
    </Tab>
    <Tab title="JS">
    ```javascript
    const result = await ditto.store.execute("SELECT * FROM cars")

    const items = result.items
    ```
    </Tab>
    <Tab title="Java">
    ```java
    DittoQueryResult result = (DittoQueryResult) ditto.store.execute(
        "SELECT * FROM cars",
        new Continuation<>() {
            @NonNull
            @Override
            public CoroutineContext getContext() {
                return EmptyCoroutineContext.INSTANCE;
            }

            @Override
            public void resumeWith(@NonNull Object o) {
                if (o instanceof Result.Failure) {
                    // Handle failure
                }
            }
        }
    );

    DittoQueryResultItems items = result.items;
    ```
    </Tab>
    <Tab title="C#">
    ```csharp
    var result = await ditto.Store.ExecuteAsync("SELECT * FROM cars");

    var items = result.Items;
    ```
    </Tab>
    <Tab title="C++">
    ```cpp
    auto result = ditto.get_store().execute("SELECT * FROM cars");

    auto items = result.items();
    ```
    </Tab>
    <Tab title="Rust">
    ```rust
    let result = ditto.store().execute("SELECT * FROM cars", None);

    let items = result.items();
    ```
    </Tab>
    <Tab title="Dart">
    ```dart
    final result = await ditto.store.execute("SELECT * FROM cars");

    final items = result.items;
    ```
    </Tab>
</Tabs>

## Working with a QueryResultItem

The result `items` object is a collection of`QueryResultItem`. Each item's value can be independently managed to meet the needs of your scenario.

### Value

To retrieve the value, call the `value` property on an item:

<Tabs>
    <Tab title="Swift">
    ```swift
    let result = await ditto.store.execute(query: "SELECT * FROM cars")

    let item = result.items[0]
    let itemValue = item.value
    let itemValueColor = item.value["color"]
    ```
    </Tab>
    <Tab title="Kotlin">
    ```kotlin
    val result = ditto.store.execute("SELECT * FROM cars")

    val item = result.items.first()
    val itemValue = item.value
    val itemValueColor = item.value["color"]
    ```
    </Tab>
    <Tab title="JS">
    ```javascript
    const result = await ditto.store.execute(`SELECT * FROM cars`)

    const item = result.items[0]
    const itemValue = item.value
    const itemValueColor = item.value["color"]
    ```
    </Tab>
    <Tab title="Java">
    ```java
    DittoQueryResult result = (DittoQueryResult) ditto.store.execute(
        "SELECT * FROM cars",
        new Continuation<>() {
            @NonNull
            @Override
            public CoroutineContext getContext() {
                return EmptyCoroutineContext.INSTANCE;
            }

            @Override
            public void resumeWith(@NonNull Object o) {
                if (o instanceof Result.Failure) {
                    // Handle failure
                }
            }
        }
    );

    DittoQueryResultItem item = result.items[0]
    Map<String, Object> itemValue = item.value
    String itemValueColor = item.value["color"].toString()
    ```
    </Tab>
    <Tab title="C#">
    ```csharp
    var result = await ditto.Store.ExecuteAsync("SELECT * FROM cars");

    var item = result.Items[0];
    var itemValue = item.Value;
    var itemValueColor = item.Value["color"] as string;
    ```
    </Tab>
    <Tab title="C++">
    ```cpp
    const auto result = ditto.store.execute(`SELECT * FROM cars`);

    auto item = result.get_item(0);
    auto item_value = item.value();
    auto item_value_color = item_value["color"];
    ```
    </Tab>
    <Tab title="Rust">
    ```rust
    let result = ditto.store().execute("SELECT * FROM cars", None);

    let item = result.items(0);
    let itemValue = item.materialize();
    ```
    </Tab>
    <Tab title="Dart">
    ```dart
    final result = await ditto.store.execute("SELECT * FROM cars");

    final item = result.items[0];
    final itemValue = item.value;
    final itemValueColor = item.value["color"];
    ```
    </Tab>
</Tabs>

### Materializing the Value

To help manage memory usage more efficiently, content associated with an `item` is lazily loaded, meaning it materializes — loads into memory — only upon the initial call to `value`.

To load the item's value into memory, use any of the following methods as appropriate:

<Tabs>
    <Tab title="Swift">
    ```swift
    // Returns `true` if value is currently held materialized in memory, otherwise returns `false`
    item.isMaterialized

    // Loads the item's value into memory
    item.materialize()

    // Release item's value from memory
    item.dematerialize()
    ```
    </Tab>
    <Tab title="Kotlin">
    ```kotlin
    // Returns `true` if value is currently held materialized in memory, otherwise returns `false`
    item.isMaterialized

    // Loads the item's value into memory
    item.materialize()

    // Release item's value from memory
    item.dematerialize()
    ```
    </Tab>
    <Tab title="JS">
    ```javascript
    // Returns `true` if value is currently held materialized in memory, otherwise returns `false`
    item.isMaterialized

    // Loads the item's value into memory
    item.materialize()

    // Release item's value from memory
    item.dematerialize()
    ```
    </Tab>
    <Tab title="Java">
    ```java
    // Returns `true` if value is currently held materialized in memory, otherwise returns `false`
    item.isMaterialized

    // Loads the item's value into memory
    item.materialize()

    // Release item's value from memory
    item.dematerialize()
    ```
    </Tab>
    <Tab title="C#">
    ```csharp
    // Returns `true` if value is currently held materialized in memory, otherwise returns `false`
    item.IsMaterialized;

    // Loads the item's value into memory
    item.Materialize();

    // Release item's value from memory
    item.Dematerialize();
    ```
    </Tab>
    <Tab title="C++">
    ```cpp
    // Returns `true` if value is currently held materialized in memory, otherwise returns `false`
    item.is_materialized()

    // Loads the item's value into memory
    item.materialize()

    // Release item's value from memory
    item.dematerialize()
    ```
    </Tab>
    <Tab title="Rust">
    ```rust
    // Loads the item's value into memory
    item.materialize();
    ```
    </Tab>
    <Tab title="Dart">
    ```dart
    // Query results are always materialized in Dart
    ```
    </Tab>
</Tabs>

### Raw CBOR Value

To access the result items as CBOR data:

<Info>
The result of this method call is not cached.
</Info>

<Tabs>
    <Tab title="Swift">
    ```swift
    let result = await ditto.store.execute(query: "SELECT * FROM cars")

    let cborSerializedItem = result.items[0].cborData()
    ```
    </Tab>
    <Tab title="Kotlin">
    ```kotlin
    val result = ditto.store.execute("SELECT * FROM cars")

    val cborItem = result.items.first().cborData()
    ```
    </Tab>
    <Tab title="JS">
    ```javascript
    const result = await ditto.store.execute(`SELECT * FROM cars`)

    const cborItem = result.items[0].cborData()
    ```
    </Tab>
    <Tab title="Java">
    ```java
    DittoQueryResult result = (DittoQueryResult) ditto.store.execute(
        "SELECT * FROM cars",
        new Continuation<>() {
            @NonNull
            @Override
            public CoroutineContext getContext() {
                return EmptyCoroutineContext.INSTANCE;
            }

            @Override
            public void resumeWith(@NonNull Object o) {
                if (o instanceof Result.Failure) {
                    // Handle failure
                }
            }
        }
    );

    byte[] cborItem = result.items[0].cborData()
    ```
    </Tab>
    <Tab title="C#">
    ```csharp
    var result = await ditto.Store.ExecuteAsync("SELECT * FROM cars");

    var cborItem = result.Items[0].CborData();
    ```
    </Tab>
    <Tab title="C++">
    ```cpp
    auto result = ditto.get_store().execute("SELECT * FROM cars");

    auto cborItem = result.get_item(0).cbor_data();
    ```
    </Tab>
    <Tab title="Rust">
    ```rust
    let result = ditto.store().execute("SELECT * FROM cars", None);

    let cborItem = result.items(0).cbor();
    ```
    </Tab>
    <Tab title="Dart">
    ```dart
    // Coming Soon
    ```
    </Tab>
</Tabs>

### Raw JSON Value

To access the result items as a JSON-string:

<Info>
The result of this method call is not cached.
</Info>

<Tabs>
    <Tab title="Swift">
    ```swift
    let result = await ditto.store.execute(query: "SELECT * FROM cars")

    let jsonSerializedItem: String = result.items[0].jsonString()

    let jsonAsData: Data = Data(jsonSerializedItem.utf8)
    ```
    </Tab>
    <Tab title="Kotlin">
    ```kotlin
    val result = ditto.store.execute("SELECT * FROM cars")

    val jsonItem = result.items.first().jsonString()
    ```
    </Tab>
    <Tab title="JS">
    ```javascript
    const result = await ditto.store.execute(`SELECT * FROM cars`)

    const jsonItem = result.items[0].jsonString()
    ```
    </Tab>
    <Tab title="Java">
    ```java
    DittoQueryResult result = (DittoQueryResult) ditto.store.execute(
        "SELECT * FROM cars",
        Collections.singletonMap("color", "blue"),
        new Continuation<>() {
            @NonNull
            @Override
            public CoroutineContext getContext() {
                return EmptyCoroutineContext.INSTANCE;
            }

            @Override
            public void resumeWith(@NonNull Object o) {
                if (o instanceof Result.Failure) {
                    // Handle failure
                }
            }
        }
    );

    String cborItem = result.items[0].jsonData()
    ```
    </Tab>
    <Tab title="C#">
    ```csharp
    var result = await ditto.Store.ExecuteAsync("SELECT * FROM cars");

    var jsonItem = result.Items[0].JsonString();
    ```
    </Tab>
    <Tab title="C++">
    ```cpp
    auto result = ditto.get_store().execute("SELECT * FROM cars");

    auto jsonItem = result.get_item(0).json_string();
    ```
    </Tab>
    <Tab title="Rust">
    ```rust
    let result = ditto.store().execute("SELECT * FROM cars", None);

    let jsonItem = result.items(0).json();
    ```
    </Tab>
    <Tab title="Dart">
    ```dart
    // Coming Soon
    ```
    </Tab>
</Tabs>

